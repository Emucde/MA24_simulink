function [arg_in_addr, res_out_addr, w_end_address] = calculate_simple_casadi_addresses(casadi_fun, casadi_fun_name, output_dir)
    %CALC_UDP_CFUN_ADDRESSES calculate addresses for c code
    %   [arg, res, w_end_address] = GENERATE_MPC_FUNCTION(casadi_fun, output_file)
    %
    %   Inputs:
    %       casadi_fun       - CasADi function object [1x1 casadi.Function]
    %       casadi_fun_input_cell - cell array with inputs and dimensions
    %       casadi_fun_output_cell - cell array with outputs and dimensions
    %       output_file - Name of the binary file to save addresses [string]
    %
    %   Outputs:
    %       arg           - Input addresses [n_in x 1 double]
    %       res           - Output addresses [n_out x 1 double]
    %       w_end_address - Total length of all inputs and outputs [1x1 double]
    
    %{
    Example of main file in MPC8.c. You can generate such a file by
    using
    
    % matlab
    >>opts = struct('main', true, 'mex', false);
    >>casadi_fun.generate(casadi_fun.name, opts);
    
    % in this example casadi_fun have the structure
    >>casadi_fun = 
    
        MPC8:(i0[1x54],i1[1x276],i2[1x180])->(o0[6],o1[1x276],o2,o3,o4,o5,o6) MXFunction
    
    % and you run it in matlab with
    >> [u_opt_sol, xx_full_opt_sol, cost_values_sol{1:length(cost_vars_SX)}] = casadi_fun(mpc_init_reference_values, init_guess_0, param_weight_init_cell);
    
    % example in MPC8.c
    casadi_int main_MPC8(casadi_int argc, char* argv[]) {
      casadi_int j;
      casadi_real* a;
      const casadi_real* r;
      casadi_int flag;
      casadi_int iw[870];
      casadi_real w[9606];
      const casadi_real* arg[23];
      casadi_real* res[17];
      arg[0] = w+0; // = start address of input "mpc_init_reference_values" // at first we calculate the input addresses
      arg[1] = w+54; // = 54+0, start address of input "init_guess_0"
      arg[2] = w+330; // = 54+276, start_address of input "param_weight_init_cell"
      res[0] = w+510; // = 54+276+180, start address of output "u_opt_sol" // then we calculate the output addresses
      res[1] = w+516; // = 54+276+180+6, start address of output "xx_full_opt_sol"
      res[2] = w+792; // = 54+276+180+6+276, start address of first cost function (only for debug)
      res[3] = w+793; // ...
      res[4] = w+794;
      res[5] = w+795;
      res[6] = w+796; // = 54+276+180+6+276+1+1+1+1, start address of last cost function (only for debug)
      a = w;
      for (j=0; j<510; ++j) if (scanf("%lg", a++)<=0) return 2;
      flag = MPC8(arg, res, iw, w+797, 0); //797 is the total length of all inputs and outputs in casadi_fun
      if (flag) return flag;
      r = w+510;
      for (j=0; j<287; ++j) CASADI_PRINTF("%g ", *r++);
      CASADI_PRINTF("\n");
      return 0;
    }
    %}
    
    % By using this code we generate a c and correspoinding header file of
    % a casadi function so that it is includable in a main c file. The
    % problem is, that the addresses for the w pointer for the inputs and
    % outputs have to be calculated, they are only autogenerated by using
    % the above command with casadi_fun.generate (or maybe there are somewhere
    % hidden in the casadi function ...)
    
        % Display dimensions
        %disp(casadi_fun.str);
        %fprintf('\n');
        %casadi_fun.print_dimensions;
    
        % Calculate addresses for casadi_real w pointer
        arg_sx = casadi_fun.sx_in;
        n_in = casadi_fun.n_in;
        arg_in_addr = zeros(n_in, 1);
    
        res_sx = casadi_fun.sx_out;
        n_out = casadi_fun.n_out;
        res_out_addr = zeros(n_out, 1);
    
        % Calculate input addresses
        for i = 2:n_in
            arg_in_addr(i) = numel(arg_sx{i-1}) + arg_in_addr(i-1);
        end
    
        % Calculate output addresses
        res_out_addr(1) = arg_in_addr(end) + numel(arg_sx{1, end});
        for i = 2:n_out
            res_out_addr(i) = numel(res_sx{i-1}) + res_out_addr(i-1);
        end
    
        % Calculate total length of all inputs and outputs
        w_end_address = casadi_fun.numel_in + casadi_fun.numel_out;
    
        % get size of casadi_int iw[?], casadi_real w[?],
        % const casadi_real* arg[?] and casadi_real* res[?]
        iw_len = casadi_fun.sz_iw;
        arg_len = casadi_fun.sz_arg;
        res_len = casadi_fun.sz_res;
        w_len = casadi_fun.sz_w + w_end_address;
    
        %% Write MPC Address binary file for c:
    
        data2save = {iw_len; arg_len; res_len; w_len; n_in; n_out; arg_in_addr; res_out_addr; w_end_address};
    
        addressdef_header_name = [casadi_fun_name, '_addressdef.h'];
        output_file = [output_dir, addressdef_header_name, '_tmp'];
        output_file_fin = [output_dir, addressdef_header_name];

        casadi_fun_name = upper(casadi_fun_name);
    
        % ARG_LEN and ARG_IN_LEN differ because ARG_LEN is the total number of
        % elements in the ARG array (which is larger than the number of
        % inputs of the MPC) and ARG_IN_LEN is the number of available
        % and defined inputs of the MPC for which the addresses need to be specified
        % and corresponds to the first n_in values of ARG.
        % In the above example,
        %
        %       const casadi_real* arg[23];
        %       casadi_real* res[17];
        %       arg[0] = w+0; // = start address of input "mpc_init_reference_values" // at first we calculate the input addresses
        %       arg[1] = w+54; // = 54+0, start address of input "init_guess_0"
        %       arg[2] = w+330; // = 54+276, start address of input "param_weight_init_cell"
        %       res[0] = w+510; // = 54+276+180, start address of output "u_opt_sol" // then we calculate the output addresses
        %       ...
        %
        % i.e., it can be seen that there are 3 inputs mpc_init_reference_values, init_guess_0, param_weight_init_cell,
        % with the addresses w+0, w+54, and w+330, i.e., n_in = 3. However, arg is an array arg[23] with 23 elements,
        % i.e., the remaining 20 elements are later defined in the MPC*.c file itself and correspond to internal
        % arguments (not documented). The same applies to res[17].
    
        define_names = {'IW_LEN', 'ARG_LEN', 'RES_LEN', 'W_LEN', 'ARG_IN_LEN', 'RES_OUT_LEN', 'ARG', 'RES', 'W_END_ADDR'};
    
        % Open a new file for writing
        fid = fopen(output_file, 'w');
    
        % Check if the file opened successfully
        if fid == -1
            error('Error opening file: %s', filename);
        end
        
        % Write the header comment
        fprintf(fid, '/* %s */\n', addressdef_header_name);
        fprintf(fid, '/* Automatically generated by MATLAB (generate_realtime_udp_c_fun.m) */\n');
        fprintf(fid, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');
        
        % Write the #ifndef guard
        fprintf(fid, '#ifndef %s\n', upper([casadi_fun_name, '_addressdef_h']));
        fprintf(fid, '#define %s\n\n', upper([casadi_fun_name, '_addressdef_h']));
    
        fprintf(fid, '#ifdef __cplusplus\n');
        fprintf(fid, 'extern "C" {\n');
        fprintf(fid, '#endif\n\n');
    
        fprintf(fid, '#include "casadi_types.h"\n\n');
    
        % Write the #define statements
        for i = 1:length(data2save)
            mpc_define_name = [casadi_fun_name, '_', define_names{i}];
            if isscalar(data2save{i})
                fprintf(fid, '#define %s %d\n', mpc_define_name, data2save{i});
            else
                % For arrays (arg and res)
                fprintf(fid, 'static const casadi_uint %s[] = {', mpc_define_name);
                fprintf(fid, '%d,', data2save{i}(1:end-1));
                fprintf(fid, '%d};\n', data2save{i}(end));
            end
        end

        % Create defines for inputs

        fprintf(fid, '\n');
        fprintf(fid, '// INPUT DIMENSIONS:\n');
        
        input_num = casadi_fun.n_in;
        input_addr_arr = zeros(1, input_num);
        var_len = 0;
        ii_cnt = 1;
        for j = 0:input_num-1
            dim = casadi_fun.size_in(j);
            name = extractBefore(casadi_fun.name_in(j), ' ');
            current_len = prod(dim);
            input_addr_arr(ii_cnt) = var_len;
            fprintf(fid, '#define %s_%s_LEN %d', casadi_fun_name, upper(name), current_len);
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            var_len = var_len + current_len;
            ii_cnt = ii_cnt + 1;
        end

        fprintf(fid, '\n');
        fprintf(fid, '// INPUT ADDRESSES:\n');

        input_num = casadi_fun.n_in;
        ii_cnt = 1;
        for j = 0:input_num-1
            dim = casadi_fun.size_in(j);
            name = extractBefore(casadi_fun.name_in(j), ' ');
            fprintf(fid, '#define %s_%s_ADDR %d', casadi_fun_name, upper(name), input_addr_arr(ii_cnt) );
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            ii_cnt = ii_cnt + 1;
        end

        % Create defines for outputs

        fprintf(fid, '\n');
        fprintf(fid, '// OUTPUT DIMENSIONS:\n');
        var_len = res_out_addr(1);
        output_num = casadi_fun.n_out;
        output_addr_arr = zeros(1, output_num);
        ii_cnt = 1;
        for j = 0:output_num-1
            dim = casadi_fun.size_out(j);
            name = extractBefore(casadi_fun.name_out(j), ' ');
            current_len = prod(dim);
            output_addr_arr(ii_cnt) = var_len;
            fprintf(fid, '#define %s_%s_LEN %d', casadi_fun_name, upper(name), current_len);
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            var_len = var_len + current_len;
            ii_cnt = ii_cnt + 1;
        end

        fprintf(fid, '\n');
        fprintf(fid, '// OUTPUT ADDRESSES:\n');

        output_num = casadi_fun.n_out;
        ii_cnt = 1;
        for j = 0:output_num-1
            dim = casadi_fun.size_out(j);
            name = extractBefore(casadi_fun.name_out(j), ' ');
            fprintf(fid, '#define %s_%s_ADDR %d', casadi_fun_name, upper(name), output_addr_arr(ii_cnt) );
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            ii_cnt = ii_cnt + 1;
        end

          
        fprintf(fid, '\n#ifdef __cplusplus\n');
        fprintf(fid, '}\n');
        fprintf(fid, '#endif\n\n');
        
        % Close the #ifndef guard
        fprintf(fid, '#endif /* %s */\n', addressdef_header_name);
        
        % Close the file
        fclose(fid);
        % check whether file changed
        if ~exist(output_file_fin, 'file') || ~isequal(fileread(output_file), fileread(output_file_fin))
            % Rename the temporary file to the final file
            movefile(output_file, output_file_fin);
            fprintf(2, ['Header file ', addressdef_header_name, ' created.\n']);
        else
            % Delete the temporary file
            delete(output_file);
            fprintf(['Header file ', addressdef_header_name, ' unchanged.\n']);
        end

    end
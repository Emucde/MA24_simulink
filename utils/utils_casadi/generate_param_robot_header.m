function generate_param_robot_header(s_fun_path, param_robot, traj_settings, func_name)

    %% Generate a C header file with the parameters of the robot model
    
    filepath = [s_fun_path, '/mpc_c_sourcefiles/'];
    func_name_upper = upper(func_name);

    h_file = [filepath, func_name, '.h_tmp'];
    c_file = [filepath, func_name, '.c_tmp'];

    h_file_fin = [filepath, func_name, '.h'];
    c_file_fin = [filepath, func_name, '.c'];

    fid_h = fopen(h_file, 'w');
    fid_c = fopen(c_file, 'w');
    if fid_h == -1
        error('Cannot open file: %s', filepath);
    end
    if fid_c == -1
        error('Cannot open file: %s', filepath);
    end

    fprintf(fid_h, '/* Automatically generated by MATLAB (generate_param_robot_header.m) */\n');
    fprintf(fid_h, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');
    
    fprintf(fid_c, '/* Automatically generated by MATLAB (generate_param_robot_header.m) */\n');
    fprintf(fid_c, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');

    fprintf(fid_c, '#include "%s.h"\n\n', func_name);

    % Write the header guard
    fprintf(fid_h, ['#ifndef ', func_name_upper, '_PARAM_H\n']);
    fprintf(fid_h, ['#define ', func_name_upper, '_PARAM_H\n\n']);

    fprintf(fid_h, '#ifdef __cplusplus\n');
    fprintf(fid_h, 'extern "C" {\n');
    fprintf(fid_h, '#endif\n\n');

    % Include necessary headers
    fprintf(fid_h, '#include "casadi_types.h"\n\n');

    % Add path to init_guess and trajectory
    param_MPC_traj_data_bin_file = fullfile(pwd, [s_fun_path, '/trajectory_data/param_traj_data.bin']);
    param_MPC_x0_init_bin_file = fullfile(pwd, [s_fun_path, '/trajectory_data/param_x0_init.bin']);
    fprintf(fid_h, '#define TRAJ_DATA_PATH "%s"\n', param_MPC_traj_data_bin_file);
    fprintf(fid_h, '#define X0_INIT_PATH "%s"\n', param_MPC_x0_init_bin_file);

    % define real length of trajectory
    fprintf(fid_h, '#define TRAJ_DATA_REAL_LEN %d\n\n', traj_settings.N_data_real);



    field_names = fieldnames(param_robot);
    for i = 1:length(field_names)
        field = field_names{i};
        field_data = param_robot.(field);
        if isscalar(field_data) && (isnumeric(field_data) || islogical(field_data))
            if(contains(field, 'indices'))
                len_name = get_indices_len_name(field, field_data, func_name_upper, param_robot);
                fprintf(fid_h, 'extern const casadi_uint %s_%s[%s];\n', func_name_upper, upper(field), len_name);
                fprintf(fid_c, 'const casadi_uint %s_%s[%s] = {%d};\n', func_name_upper, upper(field), len_name, field_data-1); % matlab starts from 1, C from 0
            else
                fprintf(fid_h, '#define %s_%s %g\n', func_name_upper, upper(field), field_data);
            end
        elseif ischar(field_data) % then it must be string
            fprintf(fid_h, '#define %s_%s "%s"\n', func_name_upper, upper(field), field_data);
        elseif ismatrix(field_data)
            len_name = get_indices_len_name(field, field_data, func_name_upper, param_robot);
            if contains(field, 'indices')
                field_data = field_data - 1; % matlab starts from 1, C from 0
                type_name = 'casadi_uint';
            else
                type_name = 'casadi_real';
            end
            fprintf(fid_h, 'extern const %s %s_%s[%s];\n', type_name, func_name_upper, upper(field), len_name);

            fprintf(fid_c, 'const %s %s_%s[%s] = {', type_name, func_name_upper, upper(field), len_name);
            fprintf(fid_c, '%d,', field_data(1:end-1));
            fprintf(fid_c, '%d};\n', field_data(end));
        else
            error('field data is neither numeric, integer nor matrix: %s', field_data);
        end
    end
    fprintf(fid_h, '\n');

    % define param_robot struct:
    structName = ['robot_config'];
    fprintf(fid_h, 'typedef struct {\n');
    fprintf(fid_h, '    const casadi_uint nq;\n');
    fprintf(fid_h, '    const casadi_uint nx;\n');
    fprintf(fid_h, '    const casadi_uint nq_red;\n');
    fprintf(fid_h, '    const casadi_uint nx_red;\n');
    fprintf(fid_h, '    const casadi_uint nq_fixed;\n');
    fprintf(fid_h, '    const casadi_uint* n_indices;\n');
    fprintf(fid_h, '    const casadi_uint* n_x_indices;\n');
    fprintf(fid_h, '    const casadi_uint* n_indices_fixed;\n');
    fprintf(fid_h, '    const casadi_uint* n_x_indices_fixed;\n');
    fprintf(fid_h, '    const casadi_uint* yt_indices;\n');
    fprintf(fid_h, '    const casadi_uint* yr_indices;\n');
    fprintf(fid_h, '    const casadi_real* q_0_ref;\n');
    fprintf(fid_h, '    const casadi_real* q_0_p_ref;\n');
    fprintf(fid_h, '    const casadi_real* q_0_pp_ref;\n');
    fprintf(fid_h, '    const casadi_real* q_limit_upper;\n');
    fprintf(fid_h, '    const casadi_real* q_limit_lower;\n');
    fprintf(fid_h, '    const casadi_real* q_p_limit_upper;\n');
    fprintf(fid_h, '    const casadi_real* q_p_limit_lower;\n');
    fprintf(fid_h, '    const casadi_real* q_pp_limit_upper;\n');
    fprintf(fid_h, '    const casadi_real* q_pp_limit_lower;\n');
    fprintf(fid_h, '    const casadi_real* q_n;\n');
    fprintf(fid_h, '    const casadi_real* torque_limit_upper;\n');
    fprintf(fid_h, '    const casadi_real* torque_limit_lower;\n');
    fprintf(fid_h, '    const casadi_real* sugihara_limb_vector;\n');
    fprintf(fid_h, '    const char* traj_data_path;\n');
    fprintf(fid_h, '    const char* x0_init_path;\n');
    fprintf(fid_h, '    const casadi_uint traj_data_real_len;\n');
    fprintf(fid_h, '} %s_t;\n\n', structName);

    % declare function that returns a robot_config_t struct
    fprintf(fid_h, 'robot_config_t get_%s();\n\n', structName);
    
    % create function that returns a robot_config_t struct
    fprintf(fid_c, '\n\n');
    fprintf(fid_c, '// Function to get the robot config\n');
    fprintf(fid_c, 'robot_config_t get_%s()\n', structName);
    fprintf(fid_c, '{\n');
    fprintf(fid_c, '   static %s_t Config = {\n', structName);
    fprintf(fid_c, '       .nq = %s_N_DOF,\n', func_name_upper);
    fprintf(fid_c, '       .nx = 2*%s_N_DOF,\n', func_name_upper);
    fprintf(fid_c, '       .nq_red = %s_N_RED,\n', func_name_upper);
    fprintf(fid_c, '       .nx_red = 2*%s_N_RED,\n', func_name_upper);
    fprintf(fid_c, '       .nq_fixed = %s_N_FIXED,\n', func_name_upper);
    fprintf(fid_c, '       .n_indices = %s_N_INDICES,\n', func_name_upper);
    fprintf(fid_c, '       .n_x_indices = %s_N_X_INDICES,\n', func_name_upper);
    fprintf(fid_c, '       .n_indices_fixed = %s_N_INDICES_FIXED,\n', func_name_upper);
    fprintf(fid_c, '       .n_x_indices_fixed = %s_N_X_INDICES_FIXED,\n', func_name_upper);
    fprintf(fid_c, '       .yt_indices = %s_YT_INDICES,\n', func_name_upper);
    fprintf(fid_c, '       .yr_indices = %s_YR_INDICES,\n', func_name_upper);
    fprintf(fid_c, '       .q_0_ref = %s_Q_0_REF,\n', func_name_upper);
    fprintf(fid_c, '       .q_0_p_ref = %s_Q_0_P_REF,\n', func_name_upper);
    fprintf(fid_c, '       .q_0_pp_ref = %s_Q_0_PP_REF,\n', func_name_upper);
    fprintf(fid_c, '       .q_limit_upper = %s_Q_LIMIT_UPPER,\n', func_name_upper);
    fprintf(fid_c, '       .q_limit_lower = %s_Q_LIMIT_LOWER,\n', func_name_upper);
    fprintf(fid_c, '       .q_p_limit_upper = %s_Q_P_LIMIT_UPPER,\n', func_name_upper);
    fprintf(fid_c, '       .q_p_limit_lower = %s_Q_P_LIMIT_LOWER,\n', func_name_upper);
    fprintf(fid_c, '       .q_pp_limit_upper = %s_Q_PP_LIMIT_UPPER,\n', func_name_upper);
    fprintf(fid_c, '       .q_pp_limit_lower = %s_Q_PP_LIMIT_LOWER,\n', func_name_upper);
    fprintf(fid_c, '       .q_n = %s_Q_N,\n', func_name_upper);
    fprintf(fid_c, '       .torque_limit_upper = %s_TORQUE_LIMIT_UPPER,\n', func_name_upper);
    fprintf(fid_c, '       .torque_limit_lower = %s_TORQUE_LIMIT_LOWER,\n', func_name_upper);
    fprintf(fid_c, '       .sugihara_limb_vector = %s_SUGIHARA_LIMB_VECTOR,\n', func_name_upper);
    fprintf(fid_c, '       .traj_data_path = TRAJ_DATA_PATH,\n');
    fprintf(fid_c, '       .x0_init_path = X0_INIT_PATH, // Default path to init configuration of trajectories\n');
    fprintf(fid_c, '       .traj_data_real_len = TRAJ_DATA_REAL_LEN, // Real length of trajectory data (without last prediction horizon)\n');
    fprintf(fid_c, '   };\n');
    fprintf(fid_c, '   return Config;\n');
    fprintf(fid_c, '}\n\n');

    fprintf(fid_h, '\n#ifdef __cplusplus\n');
    fprintf(fid_h, '}\n');
    fprintf(fid_h, '#endif\n\n');

    fprintf(fid_h, '#endif /* %s_PARAM_H */\n', func_name_upper);

    fclose(fid_h);
    fclose(fid_c);
    
    % Check if header file was changed:
    if ~exist(h_file_fin, 'file') || ~isequal(fileread(h_file), fileread(h_file_fin))
        movefile(h_file, h_file_fin, 'f');
        fprintf(2, 'Header File %s updated.\n', h_file_fin);
    else
        delete(h_file);
        fprintf('Header File %s unchanged.\n', h_file_fin);
    end

    % Check if source file was changed:
    if ~exist(c_file_fin, 'file') || ~isequal(fileread(c_file), fileread(c_file_fin))
        movefile(c_file, c_file_fin, 'f');
        fprintf(2, 'Source File %s updated.\n', c_file_fin);
    else
        delete(c_file);
        fprintf('Source File %s unchanged.\n', c_file_fin);
    end
    
end

function len_name = get_indices_len_name(field, field_data, func_name_upper, param_robot)
    if(contains(field, 'n_x_indices_fixed'))
        len_name = sprintf('2*%s_N_FIXED', func_name_upper);
    elseif(contains(field, 'n_x_indices'))
        len_name = sprintf('2*%s_N_RED', func_name_upper);
    elseif(contains(field, 'n_indices_fixed'))
        len_name = sprintf('%s_N_FIXED', func_name_upper);
    elseif(numel(field_data) == param_robot.n_red)
        len_name = sprintf('%s_N_RED', func_name_upper);
    elseif(numel(field_data) == param_robot.n_DOF)
        len_name = sprintf('%s_N_DOF', func_name_upper);
    else
        len_name = sprintf('%d', numel(field_data));
    end
end
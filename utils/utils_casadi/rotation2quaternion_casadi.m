function quaternion = rotation2quaternion_casadi(R)
    % compare rotation2quaternion.m
    eps_val = 1e-16; % Definiere den Epsilon-Wert

    % Fall 3: Bedingung f端r den dritten Fall
    quat4 = 0.5 * sqrt( 1 + R(3,3) - R(1,1) - R(2,2) );
    quaternion = [
            0.25 * (R(2,1) - R(1,2)) / quat4; ...
            0.25 * (R(1,3) + R(3,1)) / quat4; ...
            0.25 * (R(2,3) + R(3,2)) / quat4; ...
            quat4 ...
        ];
    % Fall 2: Bedingung f端r den zweiten Fall
    condition2 = R(2,2) > R(3,3);
    quat3 = 0.5 * sqrt( 1 + R(2,2) - R(1,1) - R(3,3) );
    quaternion = if_else(condition2, ...
        [
            0.25 * (R(1,3) - R(3,1)) / quat3; ...
            0.25 * (R(1,2) + R(2,1)) / quat3; ...
            quat3; ...
            0.25 * (R(2,3) + R(3,2)) / quat3 ...
        ], ...
        quaternion);

    % Fall 1: Bedingung f端r den ersten Fall
    %condition1 = logic_and(R(1,1) > R(2,2), R(1,1) > R(3,3)); % logic_and gibt es wider der Doku nicht.
    condition1a = R(1,1) > R(2,2);
    condition1b = R(1,1) > R(3,3);
    condition1c = if_else(condition1a, condition1b, false);
    condition1 = if_else(condition1c, true, false);

    quat2 = 0.5 * sqrt( 1 + R(1,1) - R(2,2) - R(3,3) );
    quaternion = if_else(condition1, ...
        [
            0.25 * (R(3,2) - R(2,3)) / quat2; ...
            quat2; ...
            0.25 * (R(1,2) + R(2,1)) / quat2; ...
            0.25 * (R(1,3) + R(3,1)) / quat2 ...
        ], ...
        quaternion);

    % Fall 0: Bedingung f端r den Null-Fall
    quat1 = 0.5 * sqrt( fmax( 0, 1 + R(1,1) + R(2,2) + R(3,3) ));
    condition0 = abs(quat1) <= eps_val;
    quaternion = if_else(condition0, ...
        quaternion, ...
        [
            quat1;
            0.25 * (R(3,2) - R(2,3)) / quat1;
            0.25 * (R(1,3) - R(3,1)) / quat1;
            0.25 * (R(2,1) - R(1,2)) / quat1
        ]);

end
function generate_mpc_config_typedef(filename, structName, unique_f_opt_input_map, unique_f_opt_output_map)
    % Default filename if not provided
    if nargin < 1 || isempty(filename)
        filename = 'mpc_config.h';
    end

    extraEntries = {
        'reference_values', ...
        'init_guess', ...
        'param_weight', ...
    };

    for i = 1:length(extraEntries)
        key = extraEntries{i};
        if ~isKey(unique_f_opt_input_map, key)
            unique_f_opt_input_map(key) = true;
        end
    end

    % Convert map keys to cell array
    unique_f_opt_input_cell = sort(keys(unique_f_opt_input_map));
    unique_f_opt_output_cell = sort(keys(unique_f_opt_output_map));

    if exist(filename, 'file')
        [existing_inputs_map, existing_outputs_map] = parse_existing_header(filename);

        sets_are_equal = true;
        for i = 1:length(unique_f_opt_input_cell)
            key = unique_f_opt_input_cell{i};
            if ~isKey(existing_inputs_map, key)
                sets_are_equal = false;
                break;
            end
        end

        for i = 1:length(unique_f_opt_output_cell)
            key = unique_f_opt_output_cell{i};
            if ~isKey(existing_outputs_map, key)
                sets_are_equal = false;
                break;
            end
        end

        if(sets_are_equal)
            fprintf('Header file %s unchanged.\n', filename);
            return;
        end
    end

    filename_fin = filename;
    filename = [filename_fin, '_tmp'];
    
    % Default struct name if not provided
    if nargin < 2 || isempty(structName)
        structName = 'mpc_config';
    end

    % Open the file for writing
    fid = fopen(filename, 'w');

    % Check if the file opened successfully
    if fid == -1
        error('Error opening file: %s', filename);
    end

    fprintf(fid, '/* Automatically generated by MATLAB (generate_mpc_config_typedef.m) */\n');
    fprintf(fid, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');

    % Write the header guard
    fprintf(fid, '#ifndef %s_H\n', upper(structName));
    fprintf(fid, '#define %s_H\n\n', upper(structName));

    fprintf(fid, '#ifdef __cplusplus\n');
    fprintf(fid, 'extern "C" {\n');
    fprintf(fid, '#endif\n\n');

    % Write necessary includes
    fprintf(fid, '#include "casadi_types.h"\n\n');

    write_struct(fid, 'mpc_input_config_t', unique_f_opt_input_cell);
    
    % Process outputs
    write_struct(fid, 'mpc_output_config_t', unique_f_opt_output_cell);

    % Write the struct definition with typedef
    fprintf(fid, 'typedef struct {\n');
    fprintf(fid, '    const casadi_real dt;\n');
    fprintf(fid, '    const casadi_uint kinematic_mpc;\n');
    fprintf(fid, '    const casadi_uint traj_data_per_horizon;\n');
    fprintf(fid, '    const casadi_uint* traj_indices;\n');
    fprintf(fid, '    casadi_uint y_d_len;\n');
    fprintf(fid, '    casadi_uint init_guess_len;\n');
    fprintf(fid, '    casadi_uint x_k_addr;\n');
    fprintf(fid, '    casadi_uint y_d_addr;\n');
    fprintf(fid, '    casadi_uint in_init_guess_addr;\n');
    fprintf(fid, '    casadi_uint out_init_guess_addr;\n');
    fprintf(fid, '    casadi_uint in_param_weight_addr;\n');
    fprintf(fid, '    const casadi_real* param_weight;\n');
    fprintf(fid, '    casadi_uint param_weight_len;\n');
    fprintf(fid, '    CasadiFunPtr_t casadi_fun;\n');
    fprintf(fid, '    const casadi_real** arg;\n');
    fprintf(fid, '    casadi_real** res;\n');
    fprintf(fid, '    casadi_int* iw;\n');
    fprintf(fid, '    casadi_real* w;\n');
    fprintf(fid, '    const casadi_uint* arg_indices;\n');
    fprintf(fid, '    const casadi_uint* res_indices;\n');
    fprintf(fid, '    casadi_uint arg_in_len;\n');
    fprintf(fid, '    casadi_uint res_out_len;\n');
    fprintf(fid, '    casadi_uint u_opt_len;\n');
    fprintf(fid, '    casadi_uint w_end_addr;\n');
    fprintf(fid, '    casadi_uint u_opt_addr;\n');
    fprintf(fid, '    int mem;\n');
    fprintf(fid, '    const mpc_input_config_t input_config;\n');
    fprintf(fid, '    const mpc_output_config_t output_config;\n');
    fprintf(fid, '} %s_t;\n\n', structName);

    fprintf(fid, '#ifdef __cplusplus\n');
    fprintf(fid, '}\n');
    fprintf(fid, '#endif\n\n');

    % Close the header guard
    fprintf(fid, '#endif // %s_H\n', upper(structName));

    % Close the file
    fclose(fid);

    % Check whether Header file was changed
    if ~exist(filename_fin, 'file') || ~isequal(fileread(filename), fileread(filename_fin))
        movefile(filename, filename_fin, 'f');
        fprintf(2, 'Header file %s has been updated.\n', filename_fin);
    else
        fprintf('Header file %s unchanged.\n', filename_fin);
        delete(filename);
    end
end


function write_struct(fid, structName, casadi_fun_cell, existing_entries)
    fprintf(fid, 'typedef struct {\n');
    
    for i = 1:length(casadi_fun_cell)
        entry_name = casadi_fun_cell{i};
        % Add the address
        fprintf(fid, '    const casadi_uint %s_addr;\n', entry_name);
        % Add the length
        fprintf(fid, '    const casadi_uint %s_len;\n', entry_name);
        existing_entries(entry_name) = true; % Mark this entry as seen
    end
    
    fprintf(fid, '} %s;\n\n', structName);
end

function [existing_inputs, existing_outputs] = parse_existing_header(filename)
    % Initialize containers to store existing inputs and outputs
    existing_inputs = containers.Map('KeyType', 'char', 'ValueType', 'any');
    existing_outputs = containers.Map('KeyType', 'char', 'ValueType', 'any');

    % Read the header file contents
    file_contents = fileread(filename);

    % Regular expression patterns to identify struct definitions
    input_pattern = 'typedef\s+struct\s*{([^}]*)}\s*mpc_input_config_t;';
    output_pattern = 'typedef\s+struct\s*{([^}]*)}\s*mpc_output_config_t;';
    
    % Find matches for input and output structs
    input_matches = regexp(file_contents, input_pattern, 'tokens');
    output_matches = regexp(file_contents, output_pattern, 'tokens');

    % Process input matches
    if ~isempty(input_matches)
        input_vars = strtrim(input_matches{1}{1});
        extract_variables(input_vars, existing_inputs);
    end

    % Process output matches
    if ~isempty(output_matches)
        output_vars = strtrim(output_matches{1}{1});
        extract_variables(output_vars, existing_outputs);
    end
end

function extract_variables(vars_section, container)
    % Split the section by lines and process each line
    lines = strsplit(vars_section, newline);
    for i = 1:length(lines)
        line = strtrim(lines{i});
        if ~isempty(line)
            % Extract variable name (assuming the format `const casadi_uint VARIABLE_name;`)
            var_pattern = 'const\s+casadi_uint\s+(\w+);\s*';
            var_match = regexp(line, var_pattern, 'tokens');
            if ~isempty(var_match)
                var_name = var_match{1}{1};  % Get the variable name from the match
                % remove _len from the variable name
                var_name = strrep(var_name, '_len', '');
                % remove _addr from the variable name
                var_name = strrep(var_name, '_addr', '');

                container(var_name) = true;  % Add to the container
            end
        end
    end
end
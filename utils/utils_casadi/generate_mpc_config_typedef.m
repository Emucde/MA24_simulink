function generate_mpc_config_typedef(filepath, unique_f_opt_input_map, unique_f_opt_output_map, param_casadi_fun_struct_list)
% generate_mpc_config_typedef - Generates a C header file for MPC configuration types.
    structName = 'mpc_config';
    typesName = [structName, '_types'];
    filename=[filepath, typesName, '.h'];
    
    mpc_configs_header = [filepath, 'mpc_configs.h'];

    % Only Update the header file if its entries have changed (Disabled)

    % Convert map keys to cell array
    % unique_f_opt_input_cell_check = sort(keys(unique_f_opt_input_map));
    % unique_f_opt_output_cell_check = sort(keys(unique_f_opt_output_map));

    % if exist(filename, 'file')
    %     [existing_inputs_map, existing_outputs_map] = parse_existing_header(filename);

    %     sets_are_equal = true;
    %     for i = 1:length(unique_f_opt_input_cell_check)
    %         key = unique_f_opt_input_cell_check{i};
    %         if ~isKey(existing_inputs_map, key)
    %             sets_are_equal = false;
    %             break;
    %         end
    %     end

    %     for i = 1:length(unique_f_opt_output_cell_check)
    %         key = unique_f_opt_output_cell_check{i};
    %         if ~isKey(existing_outputs_map, key)
    %             sets_are_equal = false;
    %             break;
    %         end
    %     end

    %     if(sets_are_equal)
    %         fprintf('Header file %s unchanged.\n', filename);
    %         return;
    %     end
    % end


    extraInputEntries = {
        'reference_values', ...
        'init_guess', ...
        'param_weight', ...
    };

    extraOutputEntries = {
        'init_guess_out', ...
    };

    % Add extra input entries to the map
    for i = 1:length(extraInputEntries)
        key = extraInputEntries{i};
        if ~isKey(unique_f_opt_input_map, key)
            unique_f_opt_input_map(key) = true;
        end
    end

    % Add extra output entries to the map
    for i = 1:length(extraOutputEntries)
        key = extraOutputEntries{i};
        if ~isKey(unique_f_opt_output_map, key)
            unique_f_opt_output_map(key) = true;
        end
    end

    unique_f_opt_input_cell = sort(keys(unique_f_opt_input_map));
    unique_f_opt_output_cell = sort(keys(unique_f_opt_output_map));

    filename_fin = filename;
    filename = [filename_fin, '_tmp'];

    % Open the file for writing
    fid = fopen(filename, 'w');

    % Check if the file opened successfully
    if fid == -1
        error('Error opening file: %s', filename);
    end

    fprintf(fid, '/* Automatically generated by MATLAB (generate_mpc_config_types.m) */\n');
    fprintf(fid, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');

    % Write the header guard
    fprintf(fid, '#ifndef %s_H\n', upper(typesName));
    fprintf(fid, '#define %s_H\n\n', upper(typesName));

    fprintf(fid, '#ifdef __cplusplus\n\n');

    % enum class CasadiMPCType
    % {
    %     MPC01,
    %     MPC6,
    %     MPC7,
    %     MPC8,
    %     MPC9,
    %     MPC10,
    %     MPC11,
    %     MPC12,
    %     MPC13,
    %     MPC14,
    %     INVALID, // Consider using INVALID for out-of-bounds
    %     COUNT    // This can denote the number of valid enum values
    % };
    mpc_names = cellfun(@(param) param.name, param_casadi_fun_struct_list, 'UniformOutput', false);

    mpc_comments = cellfun(@(param) sprintf('Version: %s,\tSolver: %s,\tTs: %s,\tN: %s,\tint: %s', ...
                                     param.version, ...
                                     param.solver, ...
                                     num2str(param.Ts), ...
                                     num2str(param.N_MPC), ...
                                     num2str(param.int_method)), ...
                                     param_casadi_fun_struct_list, 'UniformOutput', false);
    create_enum(fid, 'enum class CasadiMPCType', mpc_names, '', '', mpc_comments, true, true);
    
    % inline std::string mpctype_to_string(CasadiMPCType mpc)
    % {
    %     switch (mpc)
    %     {
    %     case CasadiMPCType::MPC01:
    %         return "MPC01";
    %     case CasadiMPCType::MPC6:
    %         return "MPC6";
    %     case CasadiMPCType::MPC7:
    %         return "MPC7";
    %     case CasadiMPCType::MPC8:
    %         return "MPC8";
    %     case CasadiMPCType::MPC9:
    %         return "MPC9";
    %     case CasadiMPCType::MPC10:
    %         return "MPC10";
    %     case CasadiMPCType::MPC11:
    %         return "MPC11";
    %     case CasadiMPCType::MPC12:
    %         return "MPC12";
    %     case CasadiMPCType::MPC13:
    %         return "MPC13";
    %     case CasadiMPCType::MPC14:
    %         return "MPC14";
    %     default:
    %         return "INVALID";
    %     }
    % }

    fprintf(fid, 'inline std::string casadi_mpctype_to_string(CasadiMPCType mpc)\n');
    fprintf(fid, '{\n');
    fprintf(fid, '    switch (mpc)\n');
    fprintf(fid, '    {\n');
    for i = 1:length(mpc_names)
        fprintf(fid, '    case CasadiMPCType::%s:\n', param_casadi_fun_struct_list{i}.name);
        fprintf(fid, '        return "%s";\n', param_casadi_fun_struct_list{i}.name);
    end
    fprintf(fid, '    default:\n');
    fprintf(fid, '        return "INVALID";\n');
    fprintf(fid, '    }\n');
    fprintf(fid, '}\n\n');

    % Create string to mpc enum function
    fprintf(fid, 'inline CasadiMPCType string_to_casadi_mpctype(const std::string& str)\n');
    fprintf(fid, '{\n');
    for i = 1:length(mpc_names)
        fprintf(fid, '    if (str == "%s")\n', param_casadi_fun_struct_list{i}.name);
        fprintf(fid, '        return CasadiMPCType::%s;\n', param_casadi_fun_struct_list{i}.name);
    end
    fprintf(fid, '    return CasadiMPCType::INVALID;\n');
    fprintf(fid, '}\n\n');

    % Create Enum for inputs
    create_enum(fid, 'enum class MPCInput', unique_f_opt_input_cell, '', '', '', true, false);

    % Create Enum for outputs
    create_enum(fid, 'enum class MPCOutput', unique_f_opt_output_cell, '', '', '', true, false);

    % create MPCInput to string functions
    fprintf(fid, 'inline std::string mpc_input_to_string(MPCInput input)\n');
    fprintf(fid, '{\n');
    fprintf(fid, '    switch (input)\n');
    fprintf(fid, '    {\n');
    for i = 1:length(unique_f_opt_input_cell)
        fprintf(fid, '    case MPCInput::%s:\n', unique_f_opt_input_cell{i});
        fprintf(fid, '        return "%s";\n', unique_f_opt_input_cell{i});
    end
    fprintf(fid, '    default:\n');
    fprintf(fid, '        return "INVALID";\n');
    fprintf(fid, '    }\n');
    fprintf(fid, '}\n\n');

    % create MPCOutput to string functions
    fprintf(fid, 'inline std::string mpc_output_to_string(MPCOutput output)\n');
    fprintf(fid, '{\n');
    fprintf(fid, '    switch (output)\n');
    fprintf(fid, '    {\n');
    for i = 1:length(unique_f_opt_output_cell)
        fprintf(fid, '    case MPCOutput::%s:\n', unique_f_opt_output_cell{i});
        fprintf(fid, '        return "%s";\n', unique_f_opt_output_cell{i});
    end
    fprintf(fid, '    default:\n');
    fprintf(fid, '        return "INVALID";\n');
    fprintf(fid, '    }\n');
    fprintf(fid, '}\n\n');

    % function to get an MPCInput by a given string
    fprintf(fid, 'inline MPCInput string_to_mpc_input(const std::string& str)\n');
    fprintf(fid, '{\n');
    for i = 1:length(unique_f_opt_input_cell)
        fprintf(fid, '    if (str == "%s")\n', unique_f_opt_input_cell{i});
        fprintf(fid, '        return MPCInput::%s;\n', unique_f_opt_input_cell{i});
    end
    fprintf(fid, '    throw std::invalid_argument("Invalid MPCInput string: " + str);\n');
    fprintf(fid, '}\n\n');

    % function to get an MPCOutput by a given string
    fprintf(fid, 'inline MPCOutput string_to_mpc_output(const std::string& str)\n');
    fprintf(fid, '{\n');
    for i = 1:length(unique_f_opt_output_cell)
        fprintf(fid, '    if (str == "%s")\n', unique_f_opt_output_cell{i});
        fprintf(fid, '        return MPCOutput::%s;\n', unique_f_opt_output_cell{i});
    end
    fprintf(fid, '    throw std::invalid_argument("Invalid MPCOutput string: " + str);\n');
    fprintf(fid, '}\n\n');

    fprintf(fid, 'extern "C" {\n');
    fprintf(fid, '#endif\n\n');

    % Write necessary includes
    fprintf(fid, '#include "casadi_types.h"\n\n');
    fprintf(fid, '#include "mpc_config_types.h"\n\n');

    % Create Enum for inputs for C
    create_enum(fid, 'typedef enum', unique_f_opt_input_cell, 'MPC_', 'mpc_input_config_id_t', '', false, false);

    % Create Enum for outputs for C
    create_enum(fid, 'typedef enum', unique_f_opt_output_cell, 'MPC_', 'mpc_output_config_id_t', '', false, false);

    % typedef struct {
    %     const casadi_uint ptr;
    %     const casadi_uint len;
    %     CasadiRefPtr_t setter_ptr;
    %     mpc_input_config_id_t id; // MPCInput enum value
    % } mpc_inout_entry_t;
    
    fprintf(fid, 'typedef struct {\n');
    fprintf(fid, '    double* const ptr;\n');
    fprintf(fid, '    const casadi_uint len;\n');
    fprintf(fid, '    const CasadiSetPtr_t set;\n');
    fprintf(fid, '    const casadi_uint id;\n');
    fprintf(fid, '} mpc_input_entry_t;\n\n');
    
    fprintf(fid, 'typedef struct {\n');
    fprintf(fid, '    double* const ptr;\n');
    fprintf(fid, '    const casadi_uint len;\n');
    fprintf(fid, '    const CasadiGetPtr_t get;\n');
    fprintf(fid, '    const casadi_uint id;\n');
    fprintf(fid, '} mpc_output_entry_t;\n\n');

    write_struct(fid, 'mpc_input_config', 'mpc_input_entry', unique_f_opt_input_cell);
    write_id_to_struct_entry_fun(fid, 'mpc_input_config', 'mpc_input_entry', unique_f_opt_input_cell);
    
    % Process outputs
    write_struct(fid, 'mpc_output_config', 'mpc_output_entry', unique_f_opt_output_cell);
    write_id_to_struct_entry_fun(fid, 'mpc_output_config', 'mpc_output_entry', unique_f_opt_output_cell);

    

    % Write the struct definition with typedef
    fprintf(fid, 'typedef struct {\n');
    fprintf(fid, '    const casadi_uint kinematic_mpc;\n');
    fprintf(fid, '    const casadi_uint planner_mpc;\n');
    fprintf(fid, '    const casadi_uint traj_data_per_horizon;\n');
    fprintf(fid, '    const casadi_uint* traj_indices;\n');
    fprintf(fid, '    const casadi_uint N_step;\n');
    fprintf(fid, '    const casadi_real* param_weight;\n');
    fprintf(fid, '    casadi_uint param_weight_len;\n');
    fprintf(fid, '    CasadiFunPtr_t casadi_fun;\n');
    fprintf(fid, '    const casadi_real** arg;\n');
    fprintf(fid, '    casadi_real** res;\n');
    fprintf(fid, '    casadi_int* iw;\n');
    fprintf(fid, '    casadi_real* w;\n');
    fprintf(fid, '    casadi_real* w_end;\n');
    fprintf(fid, '    const casadi_uint* arg_indices;\n');
    fprintf(fid, '    const casadi_uint* res_indices;\n');
    fprintf(fid, '    casadi_uint arg_in_len;\n');
    fprintf(fid, '    casadi_uint res_out_len;\n');
    fprintf(fid, '    int mem;\n');
    fprintf(fid, '    const CasadiPrevOutPtr_t set_prev_to_out;\n');
    fprintf(fid, '    const CasadiPrevOutPtr_t set_init_guess_out_to_in;\n');
    fprintf(fid, '    const mpc_input_config_t in;\n');
    fprintf(fid, '    const mpc_output_config_t out;\n');
    fprintf(fid, '} %s_t;\n\n', structName);

    fprintf(fid, '#ifdef __cplusplus\n');
    fprintf(fid, '}\n');
    fprintf(fid, '#endif\n\n');

    % Close the header guard
    fprintf(fid, '#endif // %s_H\n', upper(structName));

    % Close the file
    fclose(fid);

    % Check whether Header file was changed
    if ~exist(filename_fin, 'file') || ~isequal(fileread(filename), fileread(filename_fin))
        movefile(filename, filename_fin, 'f');
        fprintf(2, 'Header file %s has been updated.\n', filename_fin);
    else
        fprintf('Header file %s unchanged.\n', filename_fin);
        delete(filename);
    end






    % CREATE MPC CONFIGS HEADER FILE
    filename_fin = mpc_configs_header;
    mpc_configs_header = [filename_fin, '_tmp'];
    fid = fopen(mpc_configs_header, 'w');

    % Check if the file opened successfully
    if fid == -1
        error('Error opening file: %s', mpc_configs_header);
    end

    fprintf(fid, '/* Automatically generated by MATLAB (generate_mpc_config_typedef.m) */\n');
    fprintf(fid, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');

    % Write the header guard
    fprintf(fid, '#ifndef MPC_CONFIGS_H\n');
    fprintf(fid, '#define MPC_CONFIGS_H\n\n');

    fprintf(fid, '#include "mpc_config_types.h"\n\n');

    % include all mpc config headers #include "MPCX_param.h"
    for i = 1:length(mpc_names)
        fprintf(fid, '#include "%s_param.h"\n', mpc_names{i});
    end

    % Create Enum for CasadiMPCType

    % inline mpc_config_t get_mpc_config(CasadiMPCType mpc)
    % {
    %     switch (mpc)
    %     {
    %     case CasadiMPCType::MPC01:
    %         return get_MPC01_config();
    %     case CasadiMPCType::MPC6:
    %         return get_MPC6_config();
    %     case CasadiMPCType::MPC7:
    %         return get_MPC7_config();
    %     case CasadiMPCType::MPC8:
    %         return get_MPC8_config();
    %     case CasadiMPCType::MPC9:
    %         return get_MPC9_config();
    %     case CasadiMPCType::MPC10:
    %         return get_MPC10_config();
    %     case CasadiMPCType::MPC11:
    %         return get_MPC11_config();
    %     case CasadiMPCType::MPC12:
    %         return get_MPC12_config();
    %     case CasadiMPCType::MPC13:
    %         return get_MPC13_config();
    %     case CasadiMPCType::MPC14:
    %         return get_MPC14_config();
    %     default:
    %         return {};
    %     }
    % }

    fprintf(fid, 'inline mpc_config_t get_MPC_config(CasadiMPCType mpc)\n');
    fprintf(fid, '{\n');
    fprintf(fid, '    switch (mpc)\n');
    fprintf(fid, '    {\n');
    for i = 1:length(mpc_names)
        fprintf(fid, '    case CasadiMPCType::%s:\n', param_casadi_fun_struct_list{i}.name);
        fprintf(fid, '        return get_%s_config();\n', param_casadi_fun_struct_list{i}.name);
    end
    fprintf(fid, '    default:\n');
    fprintf(fid, '        return {};\n');
    fprintf(fid, '    }\n');
    fprintf(fid, '}\n\n');

    % Close the header guard
    fprintf(fid, '#endif // MPC_CONFIGS_H\n');

    % Close the file
    fclose(fid);

    % Check whether Header file was changed
    if ~exist(filename_fin, 'file') || ~isequal(fileread(mpc_configs_header), fileread(filename_fin))
        movefile(mpc_configs_header, filename_fin, 'f');
        fprintf(2, 'Header file %s has been updated.\n', filename_fin);
    else
        fprintf('Header file %s unchanged.\n', filename_fin);
        delete(mpc_configs_header);
    end
end

function write_struct(fid, structName, typename, casadi_fun_cell)
    fprintf(fid, 'typedef struct {\n');
    
    for i = 1:length(casadi_fun_cell)
        entry_name = casadi_fun_cell{i};
        fprintf(fid, '    const %s_t %s;\n',typename, entry_name);
    end
    
    fprintf(fid, '} %s_t;\n\n', structName);
end

function write_id_to_struct_entry_fun(fid, structName, typename, casadi_fun_cell)
    % Function that returns a structName pointer by a given enum from mpc_input_config_id_t
    fprintf(fid, 'inline const %s_t* get_%s(const %s_t* config, %s_id_t id)\n', typename, typename, structName, structName);
    fprintf(fid, '{\n');
    fprintf(fid, '    switch (id)\n');
    fprintf(fid, '    {\n');
    for i = 1:length(casadi_fun_cell)
        entry_name = casadi_fun_cell{i};
        fprintf(fid, '    case MPC_%s:\n', entry_name);
        fprintf(fid, '        return &config->%s;\n', entry_name);
    end
    fprintf(fid, '    default:\n');
    fprintf(fid, '        return 0;\n');
    fprintf(fid, '    }\n');
    fprintf(fid, '}\n\n');
end

function [existing_inputs, existing_outputs] = parse_existing_header(filename)
    % Initialize containers to store existing inputs and outputs
    existing_inputs = containers.Map('KeyType', 'char', 'ValueType', 'any');
    existing_outputs = containers.Map('KeyType', 'char', 'ValueType', 'any');

    % Read the header file contents
    file_contents = fileread(filename);

    % Regular expression patterns to identify struct definitions
    input_pattern = 'typedef\s+struct\s*{([^}]*)}\s*mpc_input_config_t;';
    output_pattern = 'typedef\s+struct\s*{([^}]*)}\s*mpc_output_config_t;';
    
    % Find matches for input and output structs
    input_matches = regexp(file_contents, input_pattern, 'tokens');
    output_matches = regexp(file_contents, output_pattern, 'tokens');

    % Process input matches
    if ~isempty(input_matches)
        input_vars = strtrim(input_matches{1}{1});
        extract_variables(input_vars, existing_inputs);
    end

    % Process output matches
    if ~isempty(output_matches)
        output_vars = strtrim(output_matches{1}{1});
        extract_variables(output_vars, existing_outputs);
    end
end

function extract_variables(vars_section, container)
    % Split the section by lines and process each line
    lines = strsplit(vars_section, newline);
    for i = 1:length(lines)
        line = strtrim(lines{i});
        if ~isempty(line)
            % Extract variable name (assuming the format `const casadi_uint VARIABLE_name;`)
            var_pattern = 'const\s+mpc_inout_entry_t\s+(\w+);\s*';
            var_match = regexp(line, var_pattern, 'tokens');
            if ~isempty(var_match)
                var_name = var_match{1}{1};  % Get the variable name from the match
                container(var_name) = true;  % Add to the container
            end
        end
    end
end

function create_enum(fid, enum_name, enum_values, pre_string, post_string, comment, use_count, use_invald)
    arguments
        fid
        enum_name
        enum_values
        pre_string = ''
        post_string = ''
        comment = {}
        use_count = true
        use_invald = true
    end

    if(length(comment) == 1)
        comment = repmat(comment, length(enum_values), 1);
    end

    fprintf(fid, '%s\n', enum_name);
    fprintf(fid, '{\n');
    for i = 1:length(enum_values)
        fprintf(fid, '    %s%s,', pre_string, enum_values{i});
        if ~isempty(comment)
            fprintf(fid, '\t\t// %s', comment{i});
        end
        fprintf(fid, '\n');
    end
    if use_invald
        fprintf(fid, '    INVALID,\n');
    end
    if use_count
        fprintf(fid, '    COUNT\n');
    end
    fprintf(fid, '} %s;\n\n', post_string);
end
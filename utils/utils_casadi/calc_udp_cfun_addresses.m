function [arg_in_addr, res_out_addr, w_end_address] = calc_udp_cfun_addresses(casadi_fun, casadi_fun_input_cell, casadi_fun_output_cell, output_dir)
%CALC_UDP_CFUN_ADDRESSES calculate addresses for c code
%   [arg, res, w_end_address] = GENERATE_MPC_FUNCTION(casadi_fun, output_file)
%
%   Inputs:
%       casadi_fun       - CasADi function object [1x1 casadi.Function]
%       casadi_fun_input_cell - cell array with inputs and dimensions
%       casadi_fun_output_cell - cell array with outputs and dimensions
%       output_file - Name of the binary file to save addresses [string]
%
%   Outputs:
%       arg           - Input addresses [n_in x 1 double]
%       res           - Output addresses [n_out x 1 double]
%       w_end_address - Total length of all inputs and outputs [1x1 double]

%{
Example of main file in MPC8.c. You can generate such a file by
using

% matlab
>>opts = struct('main', true, 'mex', false);
>>casadi_fun.generate(casadi_fun.name, opts);

% in this example casadi_fun have the structure
>>casadi_fun = 

    MPC8:(i0[1x54],i1[1x276],i2[1x180])->(o0[6],o1[1x276],o2,o3,o4,o5,o6) MXFunction

% and you run it in matlab with
>> [u_opt_sol, xx_full_opt_sol, cost_values_sol{1:length(cost_vars_SX)}] = casadi_fun(mpc_init_reference_values, init_guess_0, param_weight_init_cell);

% example in MPC8.c
casadi_int main_MPC8(casadi_int argc, char* argv[]) {
  casadi_int j;
  casadi_real* a;
  const casadi_real* r;
  casadi_int flag;
  casadi_int iw[870];
  casadi_real w[9606];
  const casadi_real* arg[23];
  casadi_real* res[17];
  arg[0] = w+0; // = start address of input "mpc_init_reference_values" // at first we calculate the input addresses
  arg[1] = w+54; // = 54+0, start address of input "init_guess_0"
  arg[2] = w+330; // = 54+276, start_address of input "param_weight_init_cell"
  res[0] = w+510; // = 54+276+180, start address of output "u_opt_sol" // then we calculate the output addresses
  res[1] = w+516; // = 54+276+180+6, start address of output "xx_full_opt_sol"
  res[2] = w+792; // = 54+276+180+6+276, start address of first cost function (only for debug)
  res[3] = w+793; // ...
  res[4] = w+794;
  res[5] = w+795;
  res[6] = w+796; // = 54+276+180+6+276+1+1+1+1, start address of last cost function (only for debug)
  a = w;
  for (j=0; j<510; ++j) if (scanf("%lg", a++)<=0) return 2;
  flag = MPC8(arg, res, iw, w+797, 0); //797 is the total length of all inputs and outputs in casadi_fun
  if (flag) return flag;
  r = w+510;
  for (j=0; j<287; ++j) CASADI_PRINTF("%g ", *r++);
  CASADI_PRINTF("\n");
  return 0;
}
%}

% By using this code we generate a c and correspoinding header file of
% a casadi function so that it is includable in a main c file. The
% problem is, that the addresses for the w pointer for the inputs and
% outputs have to be calculated, they are only autogenerated by using
% the above command with casadi_fun.generate (or maybe there are somewhere
% hidden in the casadi function ...)

    casadi_fun_name = casadi_fun.name;

    % Display dimensions
    %disp(casadi_fun.str);
    %fprintf('\n');
    %casadi_fun.print_dimensions;

    % Calculate addresses for casadi_real w pointer
    arg_sx = casadi_fun.sx_in;
    n_in = casadi_fun.n_in;
    arg_in_addr = zeros(n_in, 1);

    res_sx = casadi_fun.sx_out;
    n_out = casadi_fun.n_out;
    res_out_addr = zeros(n_out, 1);

    % Calculate input addresses
    for i = 2:n_in
        arg_in_addr(i) = length(arg_sx{1,i-1}) + arg_in_addr(i-1);
    end

    % Calculate output addresses
    res_out_addr(1) = arg_in_addr(end) + length(arg_sx{1, end});
    for i = 2:n_out
        res_out_addr(i) = length(res_sx{1,i-1}) + res_out_addr(i-1);
    end

    % Calculate total length of all inputs and outputs
    w_end_address = casadi_fun.numel_in + casadi_fun.numel_out;

    % get size of casadi_int iw[?], casadi_real w[?],
    % const casadi_real* arg[?] and casadi_real* res[?]
    iw_len = casadi_fun.sz_iw;
    arg_len = casadi_fun.sz_arg;
    res_len = casadi_fun.sz_res;
    w_len = casadi_fun.sz_w + w_end_address;

    %% Write MPC Address binary file for c:

    data2save = {iw_len; arg_len; res_len; w_len; n_in; n_out; arg_in_addr; res_out_addr; w_end_address};

    addressdef_header_name = [casadi_fun_name, '_addressdef.h'];
    output_file = [output_dir, addressdef_header_name];

    % ARG_LEN and ARG_IN_LEN differ because ARG_LEN is the total number of
    % elements in the ARG array (which is larger than the number of
    % inputs of the MPC) and ARG_IN_LEN is the number of available
    % and defined inputs of the MPC for which the addresses need to be specified
    % and corresponds to the first n_in values of ARG.
    % In the above example,
    %
    %       const casadi_real* arg[23];
    %       casadi_real* res[17];
    %       arg[0] = w+0; // = start address of input "mpc_init_reference_values" // at first we calculate the input addresses
    %       arg[1] = w+54; // = 54+0, start address of input "init_guess_0"
    %       arg[2] = w+330; // = 54+276, start address of input "param_weight_init_cell"
    %       res[0] = w+510; // = 54+276+180, start address of output "u_opt_sol" // then we calculate the output addresses
    %       ...
    %
    % i.e., it can be seen that there are 3 inputs mpc_init_reference_values, init_guess_0, param_weight_init_cell,
    % with the addresses w+0, w+54, and w+330, i.e., n_in = 3. However, arg is an array arg[23] with 23 elements,
    % i.e., the remaining 20 elements are later defined in the MPC*.c file itself and correspond to internal
    % arguments (not documented). The same applies to res[17].

    define_names = {'IW_LEN', 'ARG_LEN', 'RES_LEN', 'W_LEN', 'ARG_IN_LEN', 'RES_OUT_LEN', 'ARG', 'RES', 'W_END_ADDR'};

    % Open a new file for writing
    fid = fopen(output_file, 'w');

    % Check if the file opened successfully
    if fid == -1
        error('Error opening file: %s', filename);
    end
    
    % Write the header comment
    fprintf(fid, '/* %s */\n', addressdef_header_name);
    fprintf(fid, '/* Automatically generated by MATLAB (generate_realtime_udp_c_fun.m) */\n');
    fprintf(fid, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');
    
    % Write the #ifndef guard
    fprintf(fid, '#ifndef %s\n', upper([casadi_fun_name, '_addressdef_h']));
    fprintf(fid, '#define %s\n\n', upper([casadi_fun_name, '_addressdef_h']));

    fprintf(fid, '#ifdef __cplusplus\n');
    fprintf(fid, 'extern "C" {\n');
    fprintf(fid, '#endif\n\n');

    fprintf(fid, '#include "casadi_types.h"\n\n');

    % Write the #define statements
    for i = 1:length(data2save)
        mpc_define_name = [casadi_fun_name, '_', define_names{i}];
        if isscalar(data2save{i})
            fprintf(fid, '#define %s %d\n', mpc_define_name, data2save{i});
        else
            % For arrays (arg and res)
            fprintf(fid, 'static const casadi_uint %s[] = {', mpc_define_name);
            fprintf(fid, '%d,', data2save{i}(1:end-1));
            fprintf(fid, '%d};\n', data2save{i}(end));
        end
    end

    fprintf(fid, '\n');
    fprintf(fid, '// INPUT DIMENSIONS:\n');

    input_num = numel([casadi_fun_input_cell{:}]);
    input_addr_arr = zeros(1, input_num);
    var_len = 0;
    ii_cnt = 1;
    for i = 1:length(casadi_fun_input_cell)
        input_cell = casadi_fun_input_cell{i};
        for j = 1:length(input_cell)
            dim = input_cell{j}.dim;
            name = input_cell{j}.name;
            current_len = prod(dim);
            input_addr_arr(ii_cnt) = var_len;
            fprintf(fid, '#define %s_%s_LEN %d', casadi_fun_name, upper(name), current_len);
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            var_len = var_len + current_len;
            ii_cnt = ii_cnt + 1;
        end
    end

    fprintf(fid, '\n');

    %Absolute addresses of casadi_fun's inputs
    input_ref_addr_arr = zeros(1, casadi_fun.n_in);
    var_len = 0;
    ii_cnt = 1;
    for i=1:casadi_fun.n_in
        current_len = length(casadi_fun.sx_in{i});
        input_ref_addr_arr(ii_cnt) = var_len;
        input_name_cells = strsplit(casadi_fun.name_in(i-1),' = ');
        fprintf(fid, '#define %s_%s_LEN %d', casadi_fun_name, upper(input_name_cells{1}), current_len);
        fprintf(fid, '        /* %s*/\n', casadi_fun.name_in(i-1));
        var_len = var_len + current_len;
        ii_cnt = ii_cnt + 1;
    end

    fprintf(fid, '\n');
    fprintf(fid, '// INPUT ADDRESSES:\n');

    ii_cnt = 1;
    for i = 1:length(casadi_fun_input_cell)
        input_cell = casadi_fun_input_cell{i};
        for j = 1:length(input_cell)
            name = input_cell{j}.name;
            dim = input_cell{j}.dim;
            fprintf(fid, '#define %s_%s_ADDR %d', casadi_fun_name, upper(name), input_addr_arr(ii_cnt) );
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            ii_cnt = ii_cnt + 1;
        end
    end

    fprintf(fid, '\n');
    fprintf(fid, '// CASADI FUN INPUT ADDRESSES:\n');

    ii_cnt = 1;
    for i=1:casadi_fun.n_in
        input_name_cells = strsplit(casadi_fun.name_in(i-1),' = ');
        fprintf(fid, '#define %s_IN_%s_ADDR %d', casadi_fun_name, upper(input_name_cells{1}), input_ref_addr_arr(ii_cnt));
        fprintf(fid, '        /* %s*/\n', casadi_fun.name_in(i-1));
        ii_cnt = ii_cnt + 1;
    end

    %%%%%%%%%%%%%%%%%%% OUTPUTS %%%%%%%%%%%%%%%%%%%%%%%%%

    fprintf(fid, '\n');
    fprintf(fid, '// OUTPUT DIMENSIONS:\n');

    output_num = numel([casadi_fun_output_cell{:}]);
    output_addr_arr = zeros(1, output_num);
    var_len = res_out_addr(1);
    ii_cnt = 1;
    for i = 1:length(casadi_fun_output_cell)
        output_cell = casadi_fun_output_cell{i};
        for j = 1:length(output_cell)
            dim = output_cell{j}.dim;
            current_len = prod(dim);
            output_addr_arr(ii_cnt) = var_len;
            if(i==1)
                name = 'u_opt';
            else
                name = output_cell{j}.name;
            end
            fprintf(fid, '#define %s_%s_LEN %d', casadi_fun_name, upper(name), current_len);
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            var_len = var_len + current_len;
            ii_cnt = ii_cnt + 1;
        end
    end

    fprintf(fid, '\n');
    fprintf(fid, '// OUTPUT ADDRESSES:\n');

    ii_cnt = 1;
    for i = 1:length(casadi_fun_output_cell)
        output_cell = casadi_fun_output_cell{i};
        for j = 1:length(output_cell)
            dim = output_cell{j}.dim;
            if(i==1)
                name = 'u_opt';
            else
                name = output_cell{j}.name;
            end
            fprintf(fid, '#define %s_%s_ADDR %d', casadi_fun_name, upper(name), output_addr_arr(ii_cnt));
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            ii_cnt = ii_cnt + 1;
        end
    end

    fprintf(fid, '\n');
    fprintf(fid, '// CASADI FUN OUTPUT ADDRESSES:\n');

    %Absolute addresses of casadi_fun's outputs
    var_len = res_out_addr(1);
    for i=1:casadi_fun.n_out
        current_len = length(casadi_fun.sx_out{i});
        output_name_cells = strsplit(casadi_fun.name_out(i-1),' = ');
        fprintf(fid, '#define %s_OUT_%s_ADDR %d', casadi_fun_name, upper(output_name_cells{1}), var_len);
        fprintf(fid, '        /* %s*/\n', casadi_fun.name_out(i-1));
        var_len = var_len + current_len;
    end

    fprintf(fid, '\n#ifdef __cplusplus\n');
    fprintf(fid, '}\n');
    fprintf(fid, '#endif\n\n');
    
    % Close the #ifndef guard
    fprintf(fid, '#endif /* %s */\n', addressdef_header_name);
    
    % Close the file
    fclose(fid);
    
    fprintf(['Header file ', addressdef_header_name, ' created.\n']);
end
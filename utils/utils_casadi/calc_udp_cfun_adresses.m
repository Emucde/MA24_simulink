function [arg_addr, res_addr, w_end_address] = calc_udp_cfun_adresses(casadi_fun, casadi_fun_input_cell, casadi_fun_output_cell, output_dir)
%CALC_UDP_CFUN_ADRESSES calculate adresses for c code
%   [arg, res, w_end_address] = GENERATE_MPC_FUNCTION(casadi_fun, output_file)
%
%   Inputs:
%       casadi_fun       - CasADi function object [1x1 casadi.Function]
%       casadi_fun_input_cell - cell array with inputs and dimensions
%       casadi_fun_output_cell - cell array with outputs and dimensions
%       output_file - Name of the binary file to save addresses [string]
%
%   Outputs:
%       arg           - Input addresses [n_in x 1 double]
%       res           - Output addresses [n_out x 1 double]
%       w_end_address - Total length of all inputs and outputs [1x1 double]

%{
Example of main file in MPC8.c. You can generate such a file by
using

% matlab
>>opts = struct('main', true, 'mex', false);
>>casadi_fun.generate(casadi_fun.name, opts);

% in this example casadi_fun have the structure
>>casadi_fun = 

    MPC8:(i0[1x54],i1[1x276],i2[1x180])->(o0[6],o1[1x276],o2,o3,o4,o5,o6) MXFunction

% and you run it in matlab with
>> [u_opt_sol, xx_full_opt_sol, cost_values_sol{1:length(cost_vars_SX)}] = casadi_fun(mpc_init_reference_values, init_guess_0, param_weight_init_cell);

% example in MPC8.c
casadi_int main_MPC8(casadi_int argc, char* argv[]) {
  casadi_int j;
  casadi_real* a;
  const casadi_real* r;
  casadi_int flag;
  casadi_int iw[870];
  casadi_real w[9606];
  const casadi_real* arg[23];
  casadi_real* res[17];
  arg[0] = w+0; // = start adress of input "mpc_init_reference_values" // at first we calculate the input adresses
  arg[1] = w+54; // = 54+0, start adress of input "init_guess_0"
  arg[2] = w+330; // = 54+276, start_adress of input "param_weight_init_cell"
  res[0] = w+510; // = 54+276+180, start adress of output "u_opt_sol" // then we calculate the output adresses
  res[1] = w+516; // = 54+276+180+6, start adress of output "xx_full_opt_sol"
  res[2] = w+792; // = 54+276+180+6+276, start adress of first cost function (only for debug)
  res[3] = w+793; // ...
  res[4] = w+794;
  res[5] = w+795;
  res[6] = w+796; // = 54+276+180+6+276+1+1+1+1, start adress of last cost function (only for debug)
  a = w;
  for (j=0; j<510; ++j) if (scanf("%lg", a++)<=0) return 2;
  flag = MPC8(arg, res, iw, w+797, 0); //797 is the total length of all inputs and outputs in casadi_fun
  if (flag) return flag;
  r = w+510;
  for (j=0; j<287; ++j) CASADI_PRINTF("%g ", *r++);
  CASADI_PRINTF("\n");
  return 0;
}
%}

% By using this code we generate a c and correspoinding header file of
% a casadi function so that it is includable in a main c file. The
% problem is, that the adresses for the w pointer for the inputs and
% outputs have to be calculated, they are only autogenerated by using
% the above command with casadi_fun.generate (or maybe there are somewhere
% hidden in the casadi function ...)

    casadi_fun_name = casadi_fun.name;

    % Generate C code (compare "compile_casadi_sfunction.m")
    % Disable Mex Compile and create only .h and .c files for including in main.c with udp communication (gcc)
    cg_options = struct;
    cg_options.with_header = true;
    cg = casadi.CodeGenerator(casadi_fun_name, cg_options);
    cg.add(casadi_fun);
    cg.generate();

    casadi_fun_c_header_name = [casadi_fun_name, '.c'];
    casadi_fun_h_header_name = [casadi_fun_name, '.h'];

    movefile(casadi_fun_c_header_name, output_dir);
    movefile(casadi_fun_h_header_name, output_dir);

    fprintf(['Header and source files ', casadi_fun_h_header_name, ' and ', casadi_fun_c_header_name, ' created.\n']);

    % Display dimensions
    %disp(casadi_fun.str);
    %fprintf('\n');
    %casadi_fun.print_dimensions;

    % Calculate addresses for casadi_real w pointer
    arg_sx = casadi_fun.sx_in;
    n_in = casadi_fun.n_in;
    arg_addr = zeros(n_in, 1);

    res_sx = casadi_fun.sx_out;
    n_out = casadi_fun.n_out;
    res_addr = zeros(n_out-1, 1);

    % Calculate input addresses
    for i = 2:n_in
        arg_addr(i) = length(arg_sx{1,i-1}) + arg_addr(i-1);
    end

    % Calculate output addresses
    res_addr(1) = arg_addr(end) + length(arg_sx{1, end});
    for i = 2:n_out-1
        res_addr(i) = length(res_sx{1,i-1}) + res_addr(i-1);
    end

    % Calculate total length of all inputs and outputs
    w_end_address = casadi_fun.numel_in + casadi_fun.numel_out;

    % get size of casadi_int iw[?], casadi_real w[?],
    % const casadi_real* arg[?] and casadi_real* res[?]
    iw_len = casadi_fun.sz_iw;
    arg_len = casadi_fun.sz_arg;
    res_len = casadi_fun.sz_res;
    w_len = casadi_fun.sz_w + w_end_address;

    %% Write MPC Adress binary file for c:

    data2save = {iw_len; arg_len; res_len; w_len; arg_addr; res_addr; w_end_address};

    adressdef_header_name = [casadi_fun_name, '_adressdef.h'];
    output_file = [output_dir, adressdef_header_name];

    define_names = {'IW_LEN', 'ARG_LEN', 'RES_LEN', 'W_LEN', 'ARG', 'RES', 'W_END_ADDRESS'};

    % Open a new file for writing
    fid = fopen(output_file, 'w');
    
    % Write the header comment
    fprintf(fid, '/* MPC8_adressdef.h */\n');
    fprintf(fid, '/* Automatically generated by MATLAB (generate_realtime_udp_c_fun.m) */\n\n');
    
    % Write the #ifndef guard
    fprintf(fid, '#ifndef MPC8_ADRESSDEF_H\n');
    fprintf(fid, '#define MPC8_ADRESSDEF_H\n\n');
    
    % Write the #define statements
    for i = 1:length(data2save)
        mpc_define_name = [casadi_fun_name, '_', define_names{i}];
        if isscalar(data2save{i})
            fprintf(fid, '#define %s %d\n', mpc_define_name, data2save{i});
        else
            % For arrays (arg and res)
            fprintf(fid, 'static const uint32_t %s[] = {', mpc_define_name);
            fprintf(fid, '%d,', data2save{i}(1:end-1));
            fprintf(fid, '%d};\n', data2save{i}(end));
        end
    end

    fprintf(fid, '\n');
    fprintf(fid, '// INPUT DIMENSIONS:\n');

    input_num = numel([casadi_fun_input_cell{:}]);
    input_addr_arr = zeros(1, input_num);
    var_len = 0;
    ii_cnt = 1;
    for i = 1:length(casadi_fun_input_cell)
        input_cell = casadi_fun_input_cell{i};
        for j = 1:length(input_cell)
            dim = input_cell{j}.dim;
            name = input_cell{j}.name;
            current_len = prod(dim);
            input_addr_arr(ii_cnt) = var_len;
            fprintf(fid, '#define %s_LEN %d', upper(name), current_len);
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            var_len = var_len + current_len;
            ii_cnt = ii_cnt + 1;
        end
    end

    fprintf(fid, '\n');
    fprintf(fid, '// INPUT ADDRESSES:\n');

    define_names = {'REFERENCE_VALUES', 'INIT_GUESS', 'PARAM_WEIGHT'};

    input_ref_addr_arr = zeros(1, casadi_fun.n_in);
    var_len = 0;
    ii_cnt = 1;
    for i=1:length(define_names)
        current_len = length(casadi_fun.sx_in{i});
        input_ref_addr_arr(ii_cnt) = var_len;
        fprintf(fid, '#define %s_LEN %d', define_names{i}, current_len);
        fprintf(fid, '        /* %s*/\n', casadi_fun.name_in(i-1));
        var_len = var_len + current_len;
        ii_cnt = ii_cnt + 1;
    end

    ii_cnt = 1;
    for i = 1:length(casadi_fun_input_cell)
        input_cell = casadi_fun_input_cell{i};
        for j = 1:length(input_cell)
            name = input_cell{j}.name;
            dim = input_cell{j}.dim;
            fprintf(fid, '#define %s_ADDR %d', upper(name), input_addr_arr(ii_cnt) );
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            ii_cnt = ii_cnt + 1;
        end
    end

    fprintf(fid, '\n');

    ii_cnt = 1;
    for i=1:length(define_names)
        fprintf(fid, '#define %s_ADDR %d', define_names{i}, input_ref_addr_arr(ii_cnt));
        fprintf(fid, '        /* %s*/\n', casadi_fun.name_in(i-1));
        ii_cnt = ii_cnt + 1;
    end

    %%%%%%%%%%%%%%%%%%% OUTPUTS %%%%%%%%%%%%%%%%%%%%%%%%%

    fprintf(fid, '\n');
    fprintf(fid, '// OUTPUT DIMENSIONS:\n');

    output_num = numel([casadi_fun_output_cell{:}]);
    output_addr_arr = zeros(1, output_num);
    var_len = res_addr(1);
    ii_cnt = 1;
    for i = 1:length(casadi_fun_output_cell)
        output_cell = casadi_fun_output_cell{i};
        for j = 1:length(output_cell)
            dim = output_cell{j}.dim;
            current_len = prod(dim);
            output_addr_arr(ii_cnt) = var_len;
            if(i==1)
                name = 'u_opt';
            else
                name = output_cell{j}.name;
            end
            fprintf(fid, '#define %s_LEN %d', upper(name), current_len);
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            var_len = var_len + current_len;
            ii_cnt = ii_cnt + 1;
        end
    end

    fprintf(fid, '\n');
    fprintf(fid, '// OUTPUT ADDRESSES:\n');

    ii_cnt = 1;
    for i = 1:length(casadi_fun_output_cell)
        output_cell = casadi_fun_output_cell{i};
        for j = 1:length(output_cell)
            dim = output_cell{j}.dim;
            current_len = prod(dim);
            if(i==1)
                name = 'u_opt';
            else
                name = output_cell{j}.name;
            end
            fprintf(fid, '#define %s_ADDR %d', upper(name), output_addr_arr(ii_cnt));
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            ii_cnt = ii_cnt + 1;
        end
    end
    
    % Close the #ifndef guard
    fprintf(fid, '\n#endif /* MPC8_ADRESSDEF_H */\n');
    
    % Close the file
    fclose(fid);
    
    fprintf(['Header file ', adressdef_header_name, ' created.\n']);
end
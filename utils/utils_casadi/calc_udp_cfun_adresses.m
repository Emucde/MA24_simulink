function [arg, res, w_end_address] = calc_udp_cfun_adresses(casadi_fun, output_dir)
%CALC_UDP_CFUN_ADRESSES calculate adresses for c code
%   [arg, res, w_end_address] = GENERATE_MPC_FUNCTION(casadi_fun, output_file)
%
%   Inputs:
%       casadi_fun       - CasADi function object [1x1 casadi.Function]
%       output_file - Name of the binary file to save addresses [string]
%
%   Outputs:
%       arg           - Input addresses [n_in x 1 double]
%       res           - Output addresses [n_out x 1 double]
%       w_end_address - Total length of all inputs and outputs [1x1 double]

%{
Example of main file in MPC8.c. You can generate such a file by
using

% matlab
>>opts = struct('main', true, 'mex', false);
>>casadi_fun.generate(casadi_fun.name, opts);

% in this example casadi_fun have the structure
>>casadi_fun = 

    MPC8:(i0[1x54],i1[1x276],i2[1x180])->(o0[6],o1[1x276],o2,o3,o4,o5,o6) MXFunction

% and you run it in matlab with
>> [u_opt_sol, xx_full_opt_sol, cost_values_sol{1:length(cost_vars_SX)}] = casadi_fun(mpc_init_reference_values, init_guess_0, param_weight_init_cell);

% example in MPC8.c
casadi_int main_MPC8(casadi_int argc, char* argv[]) {
  casadi_int j;
  casadi_real* a;
  const casadi_real* r;
  casadi_int flag;
  casadi_int iw[870];
  casadi_real w[9606];
  const casadi_real* arg[23];
  casadi_real* res[17];
  arg[0] = w+0; // = start adress of input "mpc_init_reference_values" // at first we calculate the input adresses
  arg[1] = w+54; // = 54+0, start adress of input "init_guess_0"
  arg[2] = w+330; // = 54+276, start_adress of input "param_weight_init_cell"
  res[0] = w+510; // = 54+276+180, start adress of output "u_opt_sol" // then we calculate the output adresses
  res[1] = w+516; // = 54+276+180+6, start adress of output "xx_full_opt_sol"
  res[2] = w+792; // = 54+276+180+6+276, start adress of first cost function (only for debug)
  res[3] = w+793; // ...
  res[4] = w+794;
  res[5] = w+795;
  res[6] = w+796; // = 54+276+180+6+276+1+1+1+1, start adress of last cost function (only for debug)
  a = w;
  for (j=0; j<510; ++j) if (scanf("%lg", a++)<=0) return 2;
  flag = MPC8(arg, res, iw, w+797, 0); //797 is the total length of all inputs and outputs in casadi_fun
  if (flag) return flag;
  r = w+510;
  for (j=0; j<287; ++j) CASADI_PRINTF("%g ", *r++);
  CASADI_PRINTF("\n");
  return 0;
}
%}

% By using this code we generate a c and correspoinding header file of
% a casadi function so that it is includable in a main c file. The
% problem is, that the adresses for the w pointer for the inputs and
% outputs have to be calculated, they are only autogenerated by using
% the above command with casadi_fun.generate (or maybe there are somewhere
% hidden in the casadi function ...)

    casadi_fun_name = casadi_fun.name;

    % Generate C code (compare "compile_casadi_sfunction.m")
    cg_options = struct;
    cg_options.with_header = true;
    cg = casadi.CodeGenerator(casadi_fun_name, cg_options);
    cg.add(casadi_fun);
    cg.generate();

    casadi_fun_c_header_name = [casadi_fun_name, '.c'];
    casadi_fun_h_header_name = [casadi_fun_name, '.h'];

    movefile(casadi_fun_c_header_name, output_dir);
    movefile(casadi_fun_h_header_name, output_dir);

    % Display dimensions
    %disp(casadi_fun.str);
    %fprintf('\n');
    %casadi_fun.print_dimensions;

    % Calculate addresses for casadi_real w pointer
    arg_sx = casadi_fun.sx_in;
    n_in = casadi_fun.n_in;
    arg = zeros(n_in, 1);

    res_sx = casadi_fun.sx_out;
    n_out = casadi_fun.n_out;
    res = zeros(n_out, 1);

    % Calculate input addresses
    for i = 2:n_in
        arg(i) = length(arg_sx{1,i-1}) + arg(i-1);
    end

    % Calculate output addresses
    res(1) = arg(end) + length(arg_sx{1, end});
    for i = 2:n_out
        res(i) = length(res_sx{1,i-1}) + res(i-1);
    end

    % Calculate total length of all inputs and outputs
    w_end_address = casadi_fun.numel_in + casadi_fun.numel_out;

    % get size of casadi_int iw[?], casadi_real w[?],
    % const casadi_real* arg[?] and casadi_real* res[?]
    iw_len = casadi_fun.sz_iw;
    arg_len = casadi_fun.sz_arg;
    res_len = casadi_fun.sz_res;
    w_len = casadi_fun.sz_w + w_end_address;

    %% Write MPC Adress binary file for c:

    data2save = {iw_len; arg_len; res_len; w_len; arg; res; w_end_address};

    output_file = [output_dir, casadi_fun_name, '_adressdef.h'];

    define_names = {'IW_LEN', 'ARG_LEN', 'RES_LEN', 'W_LEN', 'ARG', 'RES', 'W_END_ADDRESS'};

    % Open a new file for writing
    fid = fopen(output_file, 'w');
    
    % Write the header comment
    fprintf(fid, '/* MPC8_adressdef.h */\n');
    fprintf(fid, '/* Automatically generated by MATLAB */\n\n');
    
    % Write the #ifndef guard
    fprintf(fid, '#ifndef MPC8_ADRESSDEF_H\n');
    fprintf(fid, '#define MPC8_ADRESSDEF_H\n\n');
    
    % Write the #define statements
    for i = 1:length(data2save)
        if isscalar(data2save{i})
            fprintf(fid, '#define %s %d\n', define_names{i}, data2save{i});
        else
            % For arrays (arg and res)
            fprintf(fid, 'static const uint32_t %s[] = {', define_names{i});
            fprintf(fid, '%d,', data2save{i}(1:end-1));
            fprintf(fid, '%d};\n', data2save{i}(end));
        end
    end
    
    % Close the #ifndef guard
    fprintf(fid, '\n#endif /* MPC8_ADRESSDEF_H */\n');
    
    % Close the file
    fclose(fid);
    
    disp('Header file MPC8_adressdef.h has been successfully created.');
end
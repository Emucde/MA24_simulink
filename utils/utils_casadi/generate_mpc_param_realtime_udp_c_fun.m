function generate_mpc_param_realtime_udp_c_fun(param_weight, param_MPC, traj_settings, func_name, output_dir, s_fun_path)
    % Open the header file for writing
    param_weight_header_name = [func_name, '_param.h'];

    fid = fopen([output_dir, param_weight_header_name], 'w');

    % Check if the file opened successfully
    if fid == -1
        error('Error opening file: %s', filename);
    end

    fprintf(fid, '/* Automatically generated by MATLAB (generate_mpc_param_realtime_udp_c_fun.m) */\n');
    fprintf(fid, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');

    % Write the header guard
    fprintf(fid, ['#ifndef ', func_name, '_PARAM_H\n']);
    fprintf(fid, ['#define ', func_name, '_PARAM_H\n\n']);

    fprintf(fid, '#ifdef __cplusplus\n');
    fprintf(fid, 'extern "C" {\n');
    fprintf(fid, '#endif\n\n');

    % Include necessary headers
    fprintf(fid, '#include <math.h>\n');
    fprintf(fid, '#include "casadi_types.h"\n');
    fprintf(fid, '#include "mpc_config.h"\n\n');
    fprintf(fid, '#include "param_robot.h"\n\n');

    % Add path to init_guess and trajectory
    param_MPC_traj_data_bin_file = fullfile(pwd, [s_fun_path, '/trajectory_data/param_traj_data.bin']);
    param_MPC_init_guess_bin_file = fullfile(pwd, [s_fun_path, '/initial_guess/param_', func_name,'_init_guess.bin']);
    param_MPC_x0_init_bin_file = fullfile(pwd, [s_fun_path, '/trajectory_data/param_x0_init.bin']);

    fprintf(fid, '#ifndef TRAJ_DATA_PATH\n');
    fprintf(fid, '#define TRAJ_DATA_PATH "%s"\n', param_MPC_traj_data_bin_file);
    fprintf(fid, '#endif\n\n');

    fprintf(fid, '#ifndef X0_INIT_PATH\n');
    fprintf(fid, '#define X0_INIT_PATH "%s"\n', param_MPC_x0_init_bin_file);
    fprintf(fid, '#endif\n\n');

    fprintf(fid, '#define %s_INIT_GUESS_PATH "%s"\n', func_name, param_MPC_init_guess_bin_file);

    fprintf(fid, '\n');

    % Add MPC Param

    fprintf(fid, '//MPC_SETTINGS:\n');

    % Get field names
    field_names = fieldnames(param_MPC);
    for i = 1:length(field_names)
        field = field_names{i};
        field_data = param_MPC.(field);
        if( isscalar(field_data) && (isnumeric(field_data) || islogical(field_data)) )
            fprintf(fid, '#define %s_%s %g\n', func_name, upper(field), field_data);
        elseif(ischar(field_data)) % then it must be string
            fprintf(fid, '#define %s_%s "%s"\n', func_name, upper(field), field_data);
        elseif(ismatrix(field_data))
            if(strcmp(field, 'traj_indices'))
                field_data = field_data-1;
                if(field_data(1) ~= 0)
                    error(['First index not 0: field_data could be corrupted: ', num2str(field_data)]);
                end
            end
            if strcmp(field, 'int_times')
                fprintf(fid, 'static const casadi_real %s_%s[] = {', func_name, upper(field));
            else
                fprintf(fid, 'static const casadi_uint %s_%s[] = {', func_name, upper(field));
            end
            fprintf(fid, '%d,', field_data(1:end-1));
            fprintf(fid, '%d};\n', field_data(end));
        else
            error(['field data is nether numeric, integer or matrix: ', field_data])
        end
    end

    % define real length of trajectory
    fprintf(fid, '#define %s_TRAJ_DATA_REAL_LEN %d\n', func_name, traj_settings.N_data_real);

    fprintf(fid, '\n');

    % Declare the function to get the MPC config
    fprintf(fid, 'mpc_config_t get_%s_config();\n\n', func_name);

    fprintf(fid, '#ifdef __cplusplus\n');
    fprintf(fid, '}\n');
    fprintf(fid, '#endif\n\n');

    % Close the header guard
    fprintf(fid, ['#endif //', func_name, '_PARAM_H\n']);

    fclose(fid);

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Write the MPC config struct in the source file

    param_weight_source_name = [func_name, '_param.c'];
    fid = fopen([output_dir, param_weight_source_name], 'w');

    % Check if the file opened successfully
    if fid == -1
        error('Error opening file: %s', filename);
    end

    fprintf(fid, '/* Automatically generated by MATLAB (generate_mpc_param_realtime_udp_c_fun.m) */\n');
    fprintf(fid, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');

    % Include the header file
    fprintf(fid, ['#include "', param_weight_header_name, '"\n']);
    fprintf(fid, '#include "mpc_config.h"\n');
    fprintf(fid, ['#include "', func_name, '_addressdef.h"\n']);
    fprintf(fid, '#include "%s.h"\n', func_name);
    fprintf(fid, '#include "casadi_types.h"\n');
    fprintf(fid, '#include "param_robot.h"\n\n');

    % create function that returns a mpc_config_t struct
    fprintf(fid, '// Function to get the MPC config\n');
    fprintf(fid, 'mpc_config_t get_%s_config()\n', func_name);
    fprintf(fid, '{\n');
    fprintf(fid, '    // Allocate memory at compile time\n');
    fprintf(fid, '    static const casadi_real* arg[%s_ARG_LEN];\n', func_name);
    fprintf(fid, '    static casadi_real* res[%s_RES_LEN];\n', func_name);
    fprintf(fid, '    static casadi_int iw[%s_IW_LEN];\n', func_name);
    fprintf(fid, '    static casadi_real w[%s_W_LEN];\n', func_name);
    fprintf(fid, '    // default parameter values, taken from ./utils/matlab_init_general/init_MPC_weights.m\n'); 
    % generate default parameter values
        % Get field names
        field_names = fieldnames(param_weight.(func_name));
    
        % Calculate total size of the array
        total_size = 0;
        for i = 1:length(field_names)
            field = field_names{i};
            total_size = total_size + numel(param_weight.(func_name).(field));
        end
        
        % Start writing the array
        % using ..param_weight[MPC8_PARAM_WEIGHT_LEN]
        fprintf(fid, '    static casadi_real %s_param_weight[%s_PARAM_WEIGHT_LEN] =\n', func_name, func_name);
        fprintf(fid, '    {\n');
            
            % Write the data for each field
            for i = 1:length(field_names)
                field = field_names{i};
                field_data = param_weight.(func_name).(field);
                field_size = size(field_data);
                
                % Add comment to indicate the start of a new field
                fprintf(fid, '    /* %s : ', field);
                
                if length(field_size) == 2 && all(field_size > 1)
                    % It's a matrix
                    fprintf(fid, '%dx%d matrix values */\n', field_size(1), field_size(2));
                    for row = 1:field_size(1)
                        fprintf(fid, '    ');
                        fprintf(fid, '%g, ', field_data(row, :));
                        fprintf(fid, '\n');
                    end
                else
                    % It's a vector or higher dimensional array
                    fprintf(fid, '%s array values */\n', mat2str(field_size));
                    fprintf(fid, '    ');
                    fprintf(fid, '%g, ', field_data(:)');
                    fprintf(fid, '\n');
                end
                
                % Add a blank line between fields for better readability
                if i < length(field_names)
                    fprintf(fid, '\n');
                end
            end
            
        % Close the array
        fprintf(fid, '    };\n');
    fprintf(fid, '\n');
    fprintf(fid, '    // Set the MPC config\n');
    fprintf(fid, ['   static mpc_config_t ', func_name, 'Config = {\n']);
    fprintf(fid, '       .kinematic_mpc = %s_KINEMATIC_MPC,\n', func_name);
    fprintf(fid, '       .x0_init_path = X0_INIT_PATH,\n');
    fprintf(fid, '       .init_guess_path = %s_INIT_GUESS_PATH,\n', func_name);
    fprintf(fid, '       .traj_data_path = TRAJ_DATA_PATH,\n');
    fprintf(fid, '       .traj_data_per_horizon = %s_TRAJ_DATA_PER_HORIZON,\n', func_name);
    fprintf(fid, '       .traj_data_real_len = %s_TRAJ_DATA_REAL_LEN,\n', func_name);
    fprintf(fid, '       .traj_indices = %s_TRAJ_INDICES,\n', func_name);
    if(strcmp(param_MPC.version, 'opt_problem_MPC_v6_kin_int_path_following') || strcmp(param_MPC.version, 'opt_problem_MPC_v6_kin_dev_path_following'))
        fprintf(fid, '       .y_d_len = %s_T_K_LEN,\n', func_name);
    else
        fprintf(fid, '       .y_d_len = %s_Y_D_LEN,\n', func_name);
    end
    fprintf(fid, '       .init_guess_len = %s_INIT_GUESS_LEN,\n', func_name);
    fprintf(fid, '       .x_k_addr = %s_X_K_ADDR,\n', func_name);
    if(strcmp(param_MPC.version, 'opt_problem_MPC_v6_kin_int_path_following') || strcmp(param_MPC.version, 'opt_problem_MPC_v6_kin_dev_path_following'))
        fprintf(fid, '       .y_d_addr = %s_T_K_ADDR,\n', func_name);
    else
        fprintf(fid, '       .y_d_addr = %s_Y_D_ADDR,\n', func_name);
    end
    fprintf(fid, '       .in_init_guess_addr = %s_IN_INIT_GUESS_ADDR,\n', func_name);
    fprintf(fid, '       .out_init_guess_addr = %s_OUT_INIT_GUESS_OUT_ADDR,\n', func_name);
    fprintf(fid, '       .in_param_weight_addr = %s_IN_PARAM_WEIGHT_ADDR,\n', func_name);
    fprintf(fid, '       .param_weight = %s_param_weight,\n', func_name);
    fprintf(fid, '       .param_weight_len = %s_PARAM_WEIGHT_LEN,\n', func_name);
    fprintf(fid, '       .casadi_fun = &%s,\n', func_name);
    fprintf(fid, '       .arg = arg,\n');
    fprintf(fid, '       .res = res,\n');
    fprintf(fid, '       .iw = iw,\n');
    fprintf(fid, '       .w = w,\n');
    fprintf(fid, '       .arg_indices = %s_ARG,\n', func_name);
    fprintf(fid, '       .res_indices = %s_RES,\n', func_name);
    fprintf(fid, '       .arg_in_len = %s_ARG_IN_LEN,\n', func_name);
    fprintf(fid, '       .res_out_len = %s_RES_OUT_LEN,\n', func_name);
    fprintf(fid, '       .u_opt_len = %s_U_OPT_LEN,\n', func_name);
    fprintf(fid, '       .w_end_addr = %s_W_END_ADDR,\n', func_name);
    fprintf(fid, '       .u_opt_addr = %s_U_OPT_ADDR,\n', func_name);
    fprintf(fid, '       .mem = 0\n');
    fprintf(fid, '   };\n');
    fprintf(fid, '   return %sConfig;\n', func_name);
    fprintf(fid, '}\n');

    % Close the file
    fclose(fid);

    fprintf('Header and source files %s and %s have been created successfully.\n', param_weight_header_name, param_weight_source_name);
end
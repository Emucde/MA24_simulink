function generate_mpc_param_realtime_udp_c_fun(param_weight, param_MPC, casadi_fun_input_cell, casadi_fun_output_cell, casadi_fun, output_dir, s_fun_path)
    % Open the header file for writing
    func_name = casadi_fun.name;

    extra_input_entries = struct;
    extra_input_entries.names = extractBefore(cellstr(casadi_fun.name_in), ' ');
    extra_input_entries.dim_text = extractAfter(cellstr(casadi_fun.name_in), '= ');

    param_weight_header_name = [func_name, '_param.h'];
    output_file = [output_dir, param_weight_header_name, '_tmp'];
    output_file_fin = [output_dir, param_weight_header_name];

    fid = fopen(output_file, 'w');

    % Check if the file opened successfully
    if fid == -1
        error('Error opening file: %s', filename);
    end

    fprintf(fid, '/* Automatically generated by MATLAB (generate_mpc_param_realtime_udp_c_fun.m) */\n');
    fprintf(fid, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');

    % Write the header guard
    fprintf(fid, ['#ifndef ', func_name, '_PARAM_H\n']);
    fprintf(fid, ['#define ', func_name, '_PARAM_H\n\n']);

    fprintf(fid, '#ifdef __cplusplus\n');
    fprintf(fid, 'extern "C" {\n');
    fprintf(fid, '#endif\n\n');

    % Include necessary headers
    fprintf(fid, '#include "casadi_types.h"\n');
    fprintf(fid, '#include "mpc_config.h"\n');

    % Add MPC Param

    fprintf(fid, '//MPC_SETTINGS:\n');

    % Get field names
    field_names = fieldnames(param_MPC);
    for i = 1:length(field_names)
        field = field_names{i};
        field_data = param_MPC.(field);
        if( isscalar(field_data) && (isnumeric(field_data) || islogical(field_data)) )
            fprintf(fid, '#define %s_%s %g\n', func_name, upper(field), field_data);
        elseif(ischar(field_data)) % then it must be string
            fprintf(fid, '#define %s_%s "%s"\n', func_name, upper(field), field_data);
        elseif(ismatrix(field_data))
            if(strcmp(field, 'traj_indices'))
                field_data = field_data-1;
                if(field_data(1) ~= 0)
                    error(['First index not 0: field_data could be corrupted: ', num2str(field_data)]);
                end
            end
            if strcmp(field, 'int_times')
                fprintf(fid, 'static const casadi_real %s_%s[] = {', func_name, upper(field));
            else
                fprintf(fid, 'static const casadi_uint %s_%s[] = {', func_name, upper(field));
            end
            fprintf(fid, '%d,', field_data(1:end-1));
            fprintf(fid, '%d};\n', field_data(end));
        else
            error(['field data is nether numeric, integer or matrix: ', field_data])
        end
    end

    fprintf(fid, '\n');

    % define setter functions
    for i = 1:length(casadi_fun_input_cell)
        input_cell = casadi_fun_input_cell{i};
        for j = 1:length(input_cell)
            dim = input_cell{j}.dim;
            name = input_cell{j}.name;

            fprintf(fid, 'inline void set_%s_%s(casadi_real *const w, casadi_real *const %s);', func_name, name, name);

            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*set %s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*set %s: %s array values */\n', name, mat2str(dim));
            end
        end
    end

    % Extra setter functions for reference_values, init_guess, and param_weight
    for i = 1:length(extra_input_entries.names)
        fprintf(fid, 'inline void set_%s_%s(casadi_real *const w, casadi_real *const %s);', func_name, extra_input_entries.names{i}, extra_input_entries.names{i});
        fprintf(fid, '        /*set %s: %s array values */\n', extra_input_entries.names{i}, extra_input_entries.dim_text{i});
    end

    fprintf(fid, '\n');

    % define getter functions
    for i = 1:length(casadi_fun_output_cell)
        output_cell = casadi_fun_output_cell{i};
        for j = 1:length(output_cell)
            dim = output_cell{j}.dim;
            name = output_cell{j}.name;

            fprintf(fid, 'inline void get_%s_%s(casadi_real *const w, casadi_real *const %s);', func_name, name, name);

            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*get %s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*get %s: %s array values */\n', name, mat2str(dim));
            end
        end
    end

    % extra getter for init_guess_out
    fprintf(fid, 'inline void get_%s_init_guess_out(casadi_real *const w, casadi_real *const init_guess_out);', func_name);

    % Declare the function to get the MPC config
    fprintf(fid, 'mpc_config_t get_%s_config();\n\n', func_name);

    fprintf(fid, '#ifdef __cplusplus\n');
    fprintf(fid, '}\n');
    fprintf(fid, '#endif\n\n');

    % Close the header guard
    fprintf(fid, ['#endif //', func_name, '_PARAM_H\n']);

    fclose(fid);

    % check whether file changed
    if ~exist(output_file_fin, 'file') || ~isequal(fileread(output_file), fileread(output_file_fin))
        % Rename the temporary file to the final file
        movefile(output_file, output_file_fin);
        fprintf(2, 'Header file %s has been created successfully.\n', param_weight_header_name);
    else
        % Delete the temporary file
        delete(output_file);
        fprintf('Header file %s unchanged.\n', param_weight_header_name);
    end






    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Write the MPC config struct in the source file

    param_weight_source_name = [func_name, '_param.c'];

    output_file = [output_dir, param_weight_source_name, '_tmp'];
    output_file_fin = [output_dir, param_weight_source_name];

    fid = fopen(output_file, 'w');

    % Check if the file opened successfully
    if fid == -1
        error('Error opening file: %s', filename);
    end

    fprintf(fid, '/* Automatically generated by MATLAB (generate_mpc_param_realtime_udp_c_fun.m) */\n');
    fprintf(fid, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');

    % Include the header file
    fprintf(fid, ['#include "', param_weight_header_name, '"\n']);
    fprintf(fid, '#include "mpc_config.h"\n');
    fprintf(fid, ['#include "', func_name, '_addressdef.h"\n']);
    fprintf(fid, '#include "%s.h"\n', func_name);
    fprintf(fid, '#include "casadi_types.h"\n');
    fprintf(fid, '#include "string.h"\n\n');

    % define setter functions
    for i = 1:length(casadi_fun_input_cell)
        input_cell = casadi_fun_input_cell{i};
        for j = 1:length(input_cell)
            dim = input_cell{j}.dim;
            name = input_cell{j}.name;

            fprintf(fid, 'void set_%s_%s(casadi_real *const w, casadi_real *const %s)\n', func_name, name, name);
            fprintf(fid, '{\n');
            fprintf(fid, '    memcpy(w + %s_%s_ADDR, %s, %s_%s_LEN * sizeof(casadi_real));', func_name, upper(name), name, func_name, upper(name));

            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            
            fprintf(fid, '}\n\n');
        end
    end

    % Extra setter functions for reference_values, init_guess, and param_weight
    for i = 1:length(extra_input_entries.names)
        fprintf(fid, 'void set_%s_%s(casadi_real *const w, casadi_real *const %s)\n', func_name, extra_input_entries.names{i}, extra_input_entries.names{i});
        fprintf(fid, '{\n');
        fprintf(fid, '    memcpy(w + %s_%s_ADDR, %s, %s_%s_LEN * sizeof(casadi_real));', func_name, upper(extra_input_entries.names{i}), extra_input_entries.names{i}, func_name, upper(extra_input_entries.names{i}));
        fprintf(fid, '        /*%s: %s array values */\n', extra_input_entries.names{i}, extra_input_entries.dim_text{i});
        fprintf(fid, '}\n\n');
    end

    % define getter functions
    for i = 1:length(casadi_fun_output_cell)
        output_cell = casadi_fun_output_cell{i};
        for j = 1:length(output_cell)
            dim = output_cell{j}.dim;
            name = output_cell{j}.name;

            fprintf(fid, 'void get_%s_%s(casadi_real *const w, casadi_real *const %s)\n', func_name, name, name);
            fprintf(fid, '{\n');
            fprintf(fid, '    memcpy(%s, w + %s_%s_ADDR, %s_%s_LEN * sizeof(casadi_real));', name, func_name, upper(name), func_name, upper(name));

            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
            
            fprintf(fid, '}\n\n');
        end
    end
    
    % extra getter for init_guess_out
    fprintf(fid, 'void get_%s_init_guess_out(casadi_real *const w, casadi_real *const init_guess_out)\n', func_name);
    fprintf(fid, '{\n');
    fprintf(fid, '    memcpy(init_guess_out, w + %s_INIT_GUESS_OUT_ADDR, %s_INIT_GUESS_LEN * sizeof(casadi_real));\n', func_name, func_name);
    fprintf(fid, '}\n\n');

    % create function that returns a mpc_config_t struct
    fprintf(fid, '// Function to get the MPC config\n');
    fprintf(fid, 'mpc_config_t get_%s_config()\n', func_name);
    fprintf(fid, '{\n');
    fprintf(fid, '    // Allocate memory at compile time\n');
    fprintf(fid, '    static const casadi_real* arg[%s_ARG_LEN];\n', func_name);
    fprintf(fid, '    static casadi_real* res[%s_RES_LEN];\n', func_name);
    fprintf(fid, '    static casadi_int iw[%s_IW_LEN];\n', func_name);
    fprintf(fid, '    static casadi_real w[%s_W_LEN];\n', func_name);
    fprintf(fid, '    // default parameter values, taken from ./utils/matlab_init_general/init_MPC_weights.m\n'); 
    % generate default parameter values

    % Get field names
    field_names = fieldnames(param_weight.(func_name));

    % Calculate total size of the array
    total_size = 0;
    for i = 1:length(field_names)
        field = field_names{i};
        total_size = total_size + numel(param_weight.(func_name).(field));
    end
    
    % Start writing the array
    % using ..param_weight[MPC8_PARAM_WEIGHT_LEN]
    fprintf(fid, '    static casadi_real %s_param_weight[%s_PARAM_WEIGHT_LEN] =\n', func_name, func_name);
    fprintf(fid, '    {\n');
        
        % Write the data for each field
        for i = 1:length(field_names)
            field = field_names{i};
            field_data = param_weight.(func_name).(field);
            field_size = size(field_data);
            
            % Add comment to indicate the start of a new field
            fprintf(fid, '    /* %s : ', field);
            
            if length(field_size) == 2 && all(field_size > 1)
                % It's a matrix
                fprintf(fid, '%dx%d matrix values */\n', field_size(1), field_size(2));
                for row = 1:field_size(1)
                    fprintf(fid, '    ');
                    fprintf(fid, '%g, ', field_data(row, :));
                    fprintf(fid, '\n');
                end
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '%s array values */\n', mat2str(field_size));
                fprintf(fid, '    ');
                fprintf(fid, '%g, ', field_data(:)');
                fprintf(fid, '\n');
            end
            
            % Add a blank line between fields for better readability
            if i < length(field_names)
                fprintf(fid, '\n');
            end
        end
        
    % Close the array
    fprintf(fid, '    };\n\n');

    % set the default parameter values
    fprintf(fid, '    // Set the MPC config\n');
    fprintf(fid, ['    mpc_config_t ', func_name, 'Config = {\n']);
    fprintf(fid, '        .kinematic_mpc = %s_KINEMATIC_MPC, // Kinematic MPC (u_opt=q0_pp, x1, q1pp) or dynamic MPC (u_opt=tau0)\n', func_name);
    fprintf(fid, '        .traj_data_per_horizon = %s_TRAJ_DATA_PER_HORIZON, // Number of trajectory data points per horizon\n', func_name);
    fprintf(fid, '        .traj_indices = %s_TRAJ_INDICES, // Local indices of the trajectory per horizon\n', func_name);
    fprintf(fid, '        .param_weight = %s_param_weight, // Parameter weights\n', func_name);
    fprintf(fid, '        .param_weight_len = %s_PARAM_WEIGHT_LEN, // Length of the parameter weights\n', func_name);
    fprintf(fid, '        .casadi_fun = &%s, // CasADi function\n', func_name);
    fprintf(fid, '        .arg = arg, // Arguments for the CasADi function\n');
    fprintf(fid, '        .res = res, // Results from the CasADi function\n');
    fprintf(fid, '        .iw = iw, // Integer workspace for the CasADi function\n');
    fprintf(fid, '        .w = w, // Real workspace for the CasADi function\n');
    fprintf(fid, '        .w_end = w+%s_W_END_ADDR, // Address of the end of the workspace\n', func_name);
    fprintf(fid, '        .arg_indices = %s_ARG, // Argument indices for the CasADi function\n', func_name);
    fprintf(fid, '        .res_indices = %s_RES, // Result indices for the CasADi function\n', func_name);
    fprintf(fid, '        .arg_in_len = %s_ARG_IN_LEN, // Length of the input arguments\n', func_name);
    fprintf(fid, '        .res_out_len = %s_RES_OUT_LEN, // Length of the output results\n', func_name);
    fprintf(fid, '        .mem = 0, // Memory\n');
    % create the mpc_input_config struct
    fprintf(fid, '        .in = {\n');
    
    for i = 1:length(casadi_fun_input_cell)
        input_cell = casadi_fun_input_cell{i};
        for j = 1:length(input_cell)
            dim = input_cell{j}.dim;
            name = input_cell{j}.name;

            % .x_k = {
            %         .ptr = w+MPC6_X_K_ADDR,
            %         .len = MPC6_X_K_LEN,
            %         .fun = &set_MPC6_x_k,
            %         .id = MPC_x_k,
            %   }

            create_mpc_inout_entry(fid, func_name, name, dim, 'set', false);
        end
    end

    % Extra setter functions for reference_values, init_guess, and param_weight
    for i = 1:length(extra_input_entries.names)
        create_mpc_inout_entry(fid, func_name, extra_input_entries.names{i}, extra_input_entries.dim_text{i}, 'set', i == length(extra_input_entries.names));
    end
    
    fprintf(fid, '       },\n');

    fprintf(fid, '       .out = {\n');
    for i = 1:length(casadi_fun_output_cell)
        output_cell = casadi_fun_output_cell{i};
        for j = 1:length(output_cell)
            dim = output_cell{j}.dim;
            name = output_cell{j}.name;

            % .u_out_addr = {
            %     .ptr = MPC6_U_OUT_ADDR,
            %     .len = MPC6_U_OUT_LEN,
            %     .fun = &get_MPC6_u_out,
            %     .id = MPC_u_out,
            % }
            create_mpc_inout_entry(fid, func_name, name, dim, 'get', false);
        end
    end

    % extra getter for init_guess_out
    create_mpc_inout_entry(fid, func_name, 'init_guess_out', "", 'get', true);

    fprintf(fid, '       }\n');
    fprintf(fid, '   };\n');
    fprintf(fid, '   return %sConfig;\n', func_name);
    fprintf(fid, '}\n');

    % Close the file
    fclose(fid);

    % check whether file changed
    if ~exist(output_file_fin, 'file') || ~isequal(fileread(output_file), fileread(output_file_fin))
        % Rename the temporary file to the final file
        movefile(output_file, output_file_fin);
        fprintf(2, 'Source file %s has been created successfully.\n', param_weight_source_name);
    else
        % Delete the temporary file
        delete(output_file);
        fprintf('Source file %s unchanged.\n', param_weight_source_name);
    end

    
end

function create_mpc_inout_entry(fid, func_name, name, dim, funstr, last)
    arguments
        fid;
        func_name;
        name;
        dim = "";
        funstr = 'set';
        last = false;
    end

    fprintf(fid, '            .%s = {', name);

    if(size(dim, 2) > 0)
        if length(dim) == 2 && all(dim > 1)
            % It's a matrix
            fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
        else
            % It's a vector or higher dimensional array
            fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
        end
    elseif(ischar(dim))
        fprintf(fid, '        /*%s: %s */\n', name, dim);
    end

    fprintf(fid, '                .ptr = w+%s_%s_ADDR,\n', func_name, upper(name));
    fprintf(fid, '                .len = %s_%s_LEN,\n', func_name, upper(name));
    fprintf(fid, '                .%s = &%s_%s_%s,\n', funstr, funstr, func_name, name);
    fprintf(fid, '                .id = (casadi_uint) MPC_%s,\n', name);
    if last
        fprintf(fid, '            }\n');
    else
        fprintf(fid, '            },\n');
    end
end
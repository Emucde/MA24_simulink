function generate_mpc_param_realtime_udp_c_fun(param_weight, param_MPC, traj_settings, casadi_fun_input_cell, casadi_fun_output_cell, func_name, output_dir, s_fun_path)
    % Open the header file for writing
    param_weight_header_name = [func_name, '_param.h'];

    fid = fopen([output_dir, param_weight_header_name], 'w');

    % Check if the file opened successfully
    if fid == -1
        error('Error opening file: %s', filename);
    end

    fprintf(fid, '/* Automatically generated by MATLAB (generate_mpc_param_realtime_udp_c_fun.m) */\n');
    fprintf(fid, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');

    % Write the header guard
    fprintf(fid, ['#ifndef ', func_name, '_PARAM_H\n']);
    fprintf(fid, ['#define ', func_name, '_PARAM_H\n\n']);

    fprintf(fid, '#ifdef __cplusplus\n');
    fprintf(fid, 'extern "C" {\n');
    fprintf(fid, '#endif\n\n');

    % Include necessary headers
    fprintf(fid, '#include <math.h>\n');
    fprintf(fid, '#include "casadi_types.h"\n');
    fprintf(fid, '#include "mpc_config.h"\n');
    fprintf(fid, '#include "param_robot.h"\n\n');

    % Add path to init_guess and trajectory
    param_MPC_traj_data_bin_file = fullfile(pwd, [s_fun_path, '/trajectory_data/param_traj_data.bin']);
    param_MPC_init_guess_bin_file = fullfile(pwd, [s_fun_path, '/initial_guess/param_', func_name,'_init_guess.bin']);
    param_MPC_x0_init_bin_file = fullfile(pwd, [s_fun_path, '/trajectory_data/param_x0_init.bin']);

    fprintf(fid, '#ifndef TRAJ_DATA_PATH\n');
    fprintf(fid, '#define TRAJ_DATA_PATH "%s"\n', param_MPC_traj_data_bin_file);
    fprintf(fid, '#endif\n\n');

    fprintf(fid, '#ifndef X0_INIT_PATH\n');
    fprintf(fid, '#define X0_INIT_PATH "%s"\n', param_MPC_x0_init_bin_file);
    fprintf(fid, '#endif\n\n');

    fprintf(fid, '#define %s_INIT_GUESS_PATH "%s"\n', func_name, param_MPC_init_guess_bin_file);

    fprintf(fid, '\n');

    % Add MPC Param

    fprintf(fid, '//MPC_SETTINGS:\n');

    % Get field names
    field_names = fieldnames(param_MPC);
    for i = 1:length(field_names)
        field = field_names{i};
        field_data = param_MPC.(field);
        if( isscalar(field_data) && (isnumeric(field_data) || islogical(field_data)) )
            fprintf(fid, '#define %s_%s %g\n', func_name, upper(field), field_data);
        elseif(ischar(field_data)) % then it must be string
            fprintf(fid, '#define %s_%s "%s"\n', func_name, upper(field), field_data);
        elseif(ismatrix(field_data))
            if(strcmp(field, 'traj_indices'))
                field_data = field_data-1;
                if(field_data(1) ~= 0)
                    error(['First index not 0: field_data could be corrupted: ', num2str(field_data)]);
                end
            end
            if strcmp(field, 'int_times')
                fprintf(fid, 'static const casadi_real %s_%s[] = {', func_name, upper(field));
            else
                fprintf(fid, 'static const casadi_uint %s_%s[] = {', func_name, upper(field));
            end
            fprintf(fid, '%d,', field_data(1:end-1));
            fprintf(fid, '%d};\n', field_data(end));
        else
            error(['field data is nether numeric, integer or matrix: ', field_data])
        end
    end

    % define real length of trajectory
    fprintf(fid, '#define %s_TRAJ_DATA_REAL_LEN %d\n', func_name, traj_settings.N_data_real);

    fprintf(fid, '\n');

    % % define setter functions
    % for i = 1:length(casadi_fun_input_cell)
    %     input_cell = casadi_fun_input_cell{i};
    %     for j = 1:length(input_cell)
    %         dim = input_cell{j}.dim;
    %         name = input_cell{j}.name;

    %         fprintf(fid, 'void set_%s_%s(casadi_real *const w, casadi_real *const %s);', func_name, name, name);

    %         if length(dim) == 2 && all(dim > 1)
    %             % It's a matrix
    %             fprintf(fid, '        /*set %s: %dx%d matrix values */\n', name, dim(1), dim(2));
    %         else
    %             % It's a vector or higher dimensional array
    %             fprintf(fid, '        /*set %s: %s array values */\n', name, mat2str(dim));
    %         end
    %     end
    % end
    % fprintf(fid, '\n');

    % Declare the function to get the MPC config
    fprintf(fid, 'mpc_config_t const* get_%s_config();\n\n', func_name);

    fprintf(fid, '#ifdef __cplusplus\n');
    fprintf(fid, '}\n');
    fprintf(fid, '#endif\n\n');

    % Close the header guard
    fprintf(fid, ['#endif //', func_name, '_PARAM_H\n']);

    fclose(fid);

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Write the MPC config struct in the source file

    param_weight_source_name = [func_name, '_param.c'];
    fid = fopen([output_dir, param_weight_source_name], 'w');

    % Check if the file opened successfully
    if fid == -1
        error('Error opening file: %s', filename);
    end

    fprintf(fid, '/* Automatically generated by MATLAB (generate_mpc_param_realtime_udp_c_fun.m) */\n');
    fprintf(fid, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');

    % Include the header file
    fprintf(fid, ['#include "', param_weight_header_name, '"\n']);
    fprintf(fid, '#include <memory.h>\n');
    fprintf(fid, '#include "mpc_config.h"\n');
    fprintf(fid, ['#include "', func_name, '_addressdef.h"\n']);
    fprintf(fid, '#include "%s.h"\n', func_name);
    fprintf(fid, '#include "casadi_types.h"\n');
    fprintf(fid, '#include "param_robot.h"\n\n');

    % % define setter functions
    % for i = 1:length(casadi_fun_input_cell)
    %     input_cell = casadi_fun_input_cell{i};
    %     for j = 1:length(input_cell)
    %         dim = input_cell{j}.dim;
    %         name = input_cell{j}.name;

    %         fprintf(fid, 'void set_%s_%s(casadi_real *const w, casadi_real *const %s)\n', func_name, name, name);
    %         fprintf(fid, '{\n');
    %         fprintf(fid, '    memcpy(w + %s_%s_ADDR, %s, %s_%s_LEN * sizeof(casadi_real));', func_name, upper(name), name, func_name, upper(name));

    %         if length(dim) == 2 && all(dim > 1)
    %             % It's a matrix
    %             fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
    %         else
    %             % It's a vector or higher dimensional array
    %             fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
    %         end
            
    %         fprintf(fid, '}\n\n');
    %     end
    % end

    % create function that returns a mpc_config_t struct
    fprintf(fid, '// Function to get the MPC config\n');
    fprintf(fid, 'mpc_config_t const* get_%s_config()\n', func_name);
    fprintf(fid, '{\n');
    fprintf(fid, '    // Allocate memory at compile time\n');
    fprintf(fid, '    static const casadi_real* arg[%s_ARG_LEN];\n', func_name);
    fprintf(fid, '    static casadi_real* res[%s_RES_LEN];\n', func_name);
    fprintf(fid, '    static casadi_int iw[%s_IW_LEN];\n', func_name);
    fprintf(fid, '    static casadi_real w[%s_W_LEN];\n', func_name);
    fprintf(fid, '    // default parameter values, taken from ./utils/matlab_init_general/init_MPC_weights.m\n'); 
    % generate default parameter values

    % Get field names
    field_names = fieldnames(param_weight.(func_name));

    % Calculate total size of the array
    total_size = 0;
    for i = 1:length(field_names)
        field = field_names{i};
        total_size = total_size + numel(param_weight.(func_name).(field));
    end
    
    % Start writing the array
    % using ..param_weight[MPC8_PARAM_WEIGHT_LEN]
    fprintf(fid, '    static casadi_real %s_param_weight[%s_PARAM_WEIGHT_LEN] =\n', func_name, func_name);
    fprintf(fid, '    {\n');
        
        % Write the data for each field
        for i = 1:length(field_names)
            field = field_names{i};
            field_data = param_weight.(func_name).(field);
            field_size = size(field_data);
            
            % Add comment to indicate the start of a new field
            fprintf(fid, '    /* %s : ', field);
            
            if length(field_size) == 2 && all(field_size > 1)
                % It's a matrix
                fprintf(fid, '%dx%d matrix values */\n', field_size(1), field_size(2));
                for row = 1:field_size(1)
                    fprintf(fid, '    ');
                    fprintf(fid, '%g, ', field_data(row, :));
                    fprintf(fid, '\n');
                end
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '%s array values */\n', mat2str(field_size));
                fprintf(fid, '    ');
                fprintf(fid, '%g, ', field_data(:)');
                fprintf(fid, '\n');
            end
            
            % Add a blank line between fields for better readability
            if i < length(field_names)
                fprintf(fid, '\n');
            end
        end
        
    % Close the array
    fprintf(fid, '    };\n\n');

    % set the default parameter values
    fprintf(fid, '    // Set the MPC config\n');
    fprintf(fid, ['   static mpc_config_t ', func_name, 'Config = {\n']);
    fprintf(fid, '       .dt = %s_DT, // Sampling time of the measured data, control frequency\n', func_name);
    fprintf(fid, '       .kinematic_mpc = %s_KINEMATIC_MPC, // Kinematic MPC (u_opt=q0_pp, x1, q1pp) or dynamic MPC (u_opt=tau0)\n', func_name);
    fprintf(fid, '       .x0_init_path = X0_INIT_PATH, // Default path to init configuration of trajectories\n');
    fprintf(fid, '       .init_guess_path = %s_INIT_GUESS_PATH, // Default path to trajectory dependent initial guess (warm start)\n', func_name);
    fprintf(fid, '       .traj_data_path = TRAJ_DATA_PATH, // Default path to trajectory data\n');
    fprintf(fid, '       .traj_data_per_horizon = %s_TRAJ_DATA_PER_HORIZON, // Number of trajectory data points per horizon\n', func_name);
    fprintf(fid, '       .traj_data_real_len = %s_TRAJ_DATA_REAL_LEN, // Real length of trajectory data (without last prediction horizon)\n', func_name);
    fprintf(fid, '       .traj_indices = %s_TRAJ_INDICES, // Local indices of the trajectory per horizon\n', func_name);
    if(strcmp(param_MPC.version, 'opt_problem_MPC_v6_kin_int_path_following') || strcmp(param_MPC.version, 'opt_problem_MPC_v6_kin_dev_path_following'))
        fprintf(fid, '       .y_d_len = %s_T_K_LEN, // Length of the desired time points (=desired path parameter) for path following\n', func_name);
    else
        fprintf(fid, '       .y_d_len = %s_Y_D_LEN, // Length of the desired trajectory per horizon\n', func_name);
    end
    fprintf(fid, '       .init_guess_len = %s_INIT_GUESS_LEN, // Length of the initial guess (warm start)\n', func_name);
    fprintf(fid, '       .x_k_addr = %s_X_K_ADDR, // Relative address of the state vector\n', func_name);
    if(strcmp(param_MPC.version, 'opt_problem_MPC_v6_kin_int_path_following') || strcmp(param_MPC.version, 'opt_problem_MPC_v6_kin_dev_path_following'))
        fprintf(fid, '       .y_d_addr = %s_T_K_ADDR, // Relative address of the desired trajectory for path following\n', func_name);
    else
        fprintf(fid, '       .y_d_addr = %s_Y_D_ADDR, // Relative address of the desired trajectory\n', func_name);
    end
    fprintf(fid, '       .in_init_guess_addr = %s_IN_INIT_GUESS_ADDR, // Relative address of the input initial guess\n', func_name);
    fprintf(fid, '       .out_init_guess_addr = %s_OUT_INIT_GUESS_OUT_ADDR, // Relative address of the output initial guess\n', func_name);
    fprintf(fid, '       .in_param_weight_addr = %s_IN_PARAM_WEIGHT_ADDR, // Relative address of the input parameter weights\n', func_name);
    fprintf(fid, '       .param_weight = %s_param_weight, // Parameter weights\n', func_name);
    fprintf(fid, '       .param_weight_len = %s_PARAM_WEIGHT_LEN, // Length of the parameter weights\n', func_name);
    fprintf(fid, '       .casadi_fun = &%s, // CasADi function\n', func_name);
    fprintf(fid, '       .arg = arg, // Arguments for the CasADi function\n');
    fprintf(fid, '       .res = res, // Results from the CasADi function\n');
    fprintf(fid, '       .iw = iw, // Integer workspace for the CasADi function\n');
    fprintf(fid, '       .w = w, // Real workspace for the CasADi function\n');
    fprintf(fid, '       .arg_indices = %s_ARG, // Argument indices for the CasADi function\n', func_name);
    fprintf(fid, '       .res_indices = %s_RES, // Result indices for the CasADi function\n', func_name);
    fprintf(fid, '       .arg_in_len = %s_ARG_IN_LEN, // Length of the input arguments\n', func_name);
    fprintf(fid, '       .res_out_len = %s_RES_OUT_LEN, // Length of the output results\n', func_name);
    fprintf(fid, '       .u_opt_len = %s_U_OPT_LEN, // Length of the optimal control input\n', func_name);
    fprintf(fid, '       .w_end_addr = %s_W_END_ADDR, // Relative address of the end of the workspace\n', func_name);
    fprintf(fid, '       .u_opt_addr = %s_U_OPT_ADDR, // Relative address of the optimal control input\n', func_name);
    fprintf(fid, '       .mem = 0, // Memory\n');
    % create the mpc_input_config struct
    fprintf(fid, '       .input_config = {\n');
    
    for i = 1:length(casadi_fun_input_cell)
        input_cell = casadi_fun_input_cell{i};
        for j = 1:length(input_cell)
            dim = input_cell{j}.dim;
            name = input_cell{j}.name;

            fprintf(fid, '              .%s_addr = %s_%s_ADDR,\n', name, func_name, upper(name));
            fprintf(fid, '              .%s_len = %s_%s_LEN,', name, func_name, upper(name));

            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
        end
    end
    % set the rest of the mpc_input_config struct
    fprintf(fid, '              .reference_values_addr = %s_IN_REFERENCE_VALUES_ADDR,\n', func_name);
    fprintf(fid, '              .reference_values_len = %s_REFERENCE_VALUES_LEN,\n', func_name);
    fprintf(fid, '              .init_guess_addr = %s_IN_INIT_GUESS_ADDR,\n', func_name);
    fprintf(fid, '              .init_guess_len = %s_INIT_GUESS_LEN,\n', func_name);
    fprintf(fid, '              .param_weight_addr = %s_IN_PARAM_WEIGHT_ADDR,\n', func_name);
    fprintf(fid, '              .param_weight_len = %s_PARAM_WEIGHT_LEN\n', func_name);
    fprintf(fid, '       },\n');

    fprintf(fid, '       .output_config = {\n');
    for i = 2:length(casadi_fun_output_cell)
        output_cell = casadi_fun_output_cell{i};
        for j = 1:length(output_cell)
            dim = output_cell{j}.dim;
            name = output_cell{j}.name;

            fprintf(fid, '              .%s_addr = %s_%s_ADDR,\n', name, func_name, upper(name));
            fprintf(fid, '              .%s_len = %s_%s_LEN,', name, func_name, upper(name));

            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
            end
        end
    end
    fprintf(fid, '       }\n');
    fprintf(fid, '   };\n');
    fprintf(fid, '   return &%sConfig;\n', func_name);
    fprintf(fid, '}\n');

    % Close the file
    fclose(fid);

    fprintf('Header and source files %s and %s have been created successfully.\n', param_weight_header_name, param_weight_source_name);
end
function generate_mpc_param_realtime_udp_c_fun(param_weight, param_MPC, casadi_fun_input_cell, casadi_fun_output_cell, refval_str_cell, casadi_fun, output_dir, s_fun_path)
    % Open the header file for writing
    func_name = casadi_fun.name;

    extra_input_entries = struct;
    extra_input_entries.names = extractBefore(cellstr(casadi_fun.name_in), ' ');
    extra_input_entries.dim_text = extractAfter(cellstr(casadi_fun.name_in), '= ');

    setter_prestring = 'set';
    getter_prestring = 'get';

    input_ref_names = cellfun(@(value) value.name,refval_str_cell, 'UniformOutput', false);
    prev_input_indices = find(contains(input_ref_names, 'prev'));
    prev_input_names = input_ref_names(prev_input_indices);
    prev_output_names = cellfun(@(name) strrep(name, 'prev', 'out'), prev_input_names, 'UniformOutput', false);
    input_prev_cell = {refval_str_cell(prev_input_indices)};
    output_prev_cell = cell(1, length(prev_input_names));
    for i = 1:length(prev_input_names)
        output_prev_cell{i} = refval_str_cell{prev_input_indices(i)};
        output_prev_cell{i}.name = strrep(output_prev_cell{i}.name, 'prev', 'out');
    end
    output_prev_cell = {output_prev_cell};

    param_weight_header_name = [func_name, '_param.h'];
    output_file = [output_dir, param_weight_header_name, '_tmp'];
    output_file_fin = [output_dir, param_weight_header_name];


    fid = fopen(output_file, 'w');

    % Check if the file opened successfully
    if fid == -1
        error('Error opening file: %s', filename);
    end

    fprintf(fid, '/* Automatically generated by MATLAB (generate_mpc_param_realtime_udp_c_fun.m) */\n');
    fprintf(fid, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');

    % Write the header guard
    fprintf(fid, ['#ifndef ', func_name, '_PARAM_H\n']);
    fprintf(fid, ['#define ', func_name, '_PARAM_H\n\n']);

    fprintf(fid, '#ifdef __cplusplus\n');
    fprintf(fid, 'extern "C" {\n');
    fprintf(fid, '#endif\n\n');

    % Include necessary headers
    fprintf(fid, '#include "casadi_types.h"\n');
    fprintf(fid, '#include "mpc_config_types.h"\n');

    % Add MPC Param

    fprintf(fid, '//MPC_SETTINGS:\n');

    % Get field names
    field_names = fieldnames(param_MPC);
    for i = 1:length(field_names)
        field = field_names{i};
        field_data = param_MPC.(field);
        if( isscalar(field_data) && (isnumeric(field_data) || islogical(field_data)) )
            fprintf(fid, '#define %s_%s %g\n', func_name, upper(field), field_data);
        elseif(ischar(field_data)) % then it must be string
            fprintf(fid, '#define %s_%s "%s"\n', func_name, upper(field), field_data);
        elseif(ismatrix(field_data))
            if(strcmp(field, 'traj_indices'))
                field_data = field_data-1;
                if(field_data(1) ~= 0)
                    error(['First index not 0: field_data could be corrupted: ', num2str(field_data)]);
                end
            end
            if strcmp(field, 'int_times')
                fprintf(fid, 'static const casadi_real %s_%s[] = {', func_name, upper(field));
            else
                fprintf(fid, 'static const casadi_uint %s_%s[] = {', func_name, upper(field));
            end
            fprintf(fid, '%d,', field_data(1:end-1));
            fprintf(fid, '%d};\n', field_data(end));
        else
            error(['field data is nether numeric, integer or matrix: ', field_data])
        end
    end

    fprintf(fid, '\n');

    % define setter functions
    generate_function_declarations(fid, setter_prestring, casadi_fun_input_cell, func_name);

    % Extra setter functions for reference_values, init_guess, and param_weight
    for i = 1:length(extra_input_entries.names)
        fprintf(fid, 'void set_%s_%s(casadi_real *const w, casadi_real *const %s);', func_name, extra_input_entries.names{i}, extra_input_entries.names{i});
        fprintf(fid, '        /*set %s: %s array values */\n', extra_input_entries.names{i}, extra_input_entries.dim_text{i});
    end

    % setter for prev_to_out functions
    generate_prev_to_out_declarations(fid, setter_prestring, input_prev_cell, output_prev_cell, func_name);
    fprintf(fid, 'void set_prev_to_out_%s(casadi_real *const w);\n', func_name);
    fprintf(fid, 'void set_init_guess_out_to_in_%s(casadi_real *const w);\n\n', func_name);

    % Declare the function to get the MPC config
    fprintf(fid, 'mpc_config_t get_%s_config();\n\n', func_name);

    fprintf(fid, '#ifdef __cplusplus\n');
    fprintf(fid, '}\n');
    fprintf(fid, '#endif\n\n');

    fprintf(fid, '\n');

    generate_function_declarations(fid, getter_prestring, casadi_fun_output_cell, func_name);

    % extra getter for init_guess_out
    fprintf(fid, 'void get_%s_init_guess_out(casadi_real *const w, casadi_real *const init_guess_out);\n', func_name);

    % Close the header guard
    fprintf(fid, ['#endif //', func_name, '_PARAM_H\n']);

    fclose(fid);

    % check whether file changed
    if ~exist(output_file_fin, 'file') || ~isequal(fileread(output_file), fileread(output_file_fin))
        % Rename the temporary file to the final file
        movefile(output_file, output_file_fin);
        fprintf(2, 'Header file %s has been created successfully.\n', param_weight_header_name);
    else
        % Delete the temporary file
        delete(output_file);
        fprintf('Header file %s unchanged.\n', param_weight_header_name);
    end






    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Write the MPC config struct in the source file

    param_weight_source_name = [func_name, '_param.c'];

    output_file = [output_dir, param_weight_source_name, '_tmp'];
    output_file_fin = [output_dir, param_weight_source_name];

    fid = fopen(output_file, 'w');

    % Check if the file opened successfully
    if fid == -1
        error('Error opening file: %s', filename);
    end

    fprintf(fid, '/* Automatically generated by MATLAB (generate_mpc_param_realtime_udp_c_fun.m) */\n');
    fprintf(fid, '/* Do not edit this file. To regenerate, run "mpc_casdadi_main.m" with "generate_realtime_udp_c_fun=true" */\n\n');

    % Include the header file
    fprintf(fid, ['#include "', param_weight_header_name, '"\n']);
    fprintf(fid, ['#include "', func_name, '_addressdef.h"\n']);
    fprintf(fid, '#include "%s.h"\n', func_name);
    fprintf(fid, '#include "casadi_types.h"\n');
    fprintf(fid, '#include "string.h"\n\n');

    fprintf(fid, '\n');
    fprintf(fid, '////////////////////////////////////////////////////////////////////////////////\n');
    fprintf(fid, '/////////////////////////////////////    SETTER    /////////////////////////////\n');
    fprintf(fid, '////////////////////////////////////////////////////////////////////////////////\n');
    fprintf(fid, '\n');

    % define setter functions
    is_setter=true;
    generate_set_get_functions(fid, func_name, setter_prestring, casadi_fun_input_cell, is_setter)

    % Extra setter functions for reference_values, init_guess, and param_weight
    for i = 1:length(extra_input_entries.names)
        fprintf(fid, 'void set_%s_%s(casadi_real *const w, casadi_real *const %s) {\n', func_name, extra_input_entries.names{i}, extra_input_entries.names{i});
        fprintf(fid, '    memcpy(w + %s_%s_ADDR, %s, %s_%s_LEN * sizeof(casadi_real));', func_name, upper(extra_input_entries.names{i}), extra_input_entries.names{i}, func_name, upper(extra_input_entries.names{i}));
        fprintf(fid, '        /*%s: %s array values */\n', extra_input_entries.names{i}, extra_input_entries.dim_text{i});
        fprintf(fid, '}\n');
    end

    fprintf(fid, '\n');
    fprintf(fid, '////////////////////////////////////////////////////////////////////////////////\n');
    fprintf(fid, '/////////////////////////////////////   PREV SETTER    /////////////////////////\n');
    fprintf(fid, '////////////////////////////////////////////////////////////////////////////////\n');
    fprintf(fid, '\n');

    % define set prev to out setter functions
    
    generate_prev_to_out_functions(fid, 'set', input_prev_cell, output_prev_cell, func_name);


    % common prev to out function
    fprintf(fid, 'void set_prev_to_out_%s(casadi_real *const w) {\n', func_name);
    for i = 1:length(prev_input_names)
        fprintf(fid, '    memcpy(w + %s_%s_ADDR, w + %s_%s_ADDR, %s_%s_LEN * sizeof(casadi_real));\n', ...
            func_name, upper(prev_input_names{i}), func_name, upper(prev_output_names{i}), ...
            func_name, upper(prev_output_names{i}));
            if(strcmp(prev_input_names{i}, 'z_prev')) % add increment function
                fprintf(fid, '    memcpy(w + %s_Z_K_ADDR, w + %s_Z_K_LEN + %s_Z_OUT_ADDR, %s_Z_K_LEN * sizeof(casadi_real));\n', func_name, func_name, func_name, func_name);
            end
    end
    fprintf(fid, '}\n');

    % extra setter for init_guess_out
    fprintf(fid, 'void set_init_guess_out_to_in_%s(casadi_real *const w) {\n', func_name);
    fprintf(fid, '    memcpy(w + %s_INIT_GUESS_ADDR, w + %s_INIT_GUESS_OUT_ADDR, %s_INIT_GUESS_LEN * sizeof(casadi_real));\n', func_name, func_name, func_name);
    fprintf(fid, '}\n\n');

    fprintf(fid, '\n');
    fprintf(fid, '////////////////////////////////////////////////////////////////////////////////\n');
    fprintf(fid, '/////////////////////////////////////    GETTER    /////////////////////////////\n');
    fprintf(fid, '////////////////////////////////////////////////////////////////////////////////\n');
    fprintf(fid, '\n');

    % define getter functions
    is_setter=false;
    generate_set_get_functions(fid, func_name, getter_prestring, casadi_fun_output_cell, is_setter)
    
    % extra getter for init_guess_out
    fprintf(fid, 'void get_%s_init_guess_out(casadi_real *const w, casadi_real *const init_guess_out)\n', func_name);
    fprintf(fid, '{\n');
    fprintf(fid, '    memcpy(init_guess_out, w + %s_INIT_GUESS_OUT_ADDR, %s_INIT_GUESS_LEN * sizeof(casadi_real));\n', func_name, func_name);
    fprintf(fid, '}\n\n');

    % create function that returns a mpc_config_t struct
    fprintf(fid, '////////////////////////////////////////////////////////////////////////////////\n');
    fprintf(fid, '/////////////////////////////////////    CONFIG    /////////////////////////////\n');
    fprintf(fid, '////////////////////////////////////////////////////////////////////////////////\n');
    fprintf(fid, '\n');
    fprintf(fid, '// Function to get the MPC config\n');
    fprintf(fid, 'mpc_config_t get_%s_config()\n', func_name);
    fprintf(fid, '{\n');
    fprintf(fid, '    // Allocate memory at compile time\n');
    fprintf(fid, '    static const casadi_real* arg[%s_ARG_LEN];\n', func_name);
    fprintf(fid, '    static casadi_real* res[%s_RES_LEN];\n', func_name);
    fprintf(fid, '    static casadi_int iw[%s_IW_LEN];\n', func_name);
    fprintf(fid, '    static casadi_real w[%s_W_LEN];\n', func_name);
    fprintf(fid, '    // default parameter values, taken from ./utils/matlab_init_general/init_MPC_weights.m\n'); 
    % generate default parameter values

    % Get field names
    field_names = fieldnames(param_weight.(func_name));

    % Calculate total size of the array
    total_size = 0;
    for i = 1:length(field_names)
        field = field_names{i};
        total_size = total_size + numel(param_weight.(func_name).(field));
    end
    
    % Start writing the array
    % using ..param_weight[MPC8_PARAM_WEIGHT_LEN]
    fprintf(fid, '    static casadi_real %s_param_weight[%s_PARAM_WEIGHT_LEN] =\n', func_name, func_name);
    fprintf(fid, '    {\n');
        
        % Write the data for each field
        for i = 1:length(field_names)
            field = field_names{i};
            field_data = param_weight.(func_name).(field);
            field_size = size(field_data);
            
            % Add comment to indicate the start of a new field
            fprintf(fid, '    /* %s : ', field);
            
            if length(field_size) == 2 && all(field_size > 1)
                % It's a matrix
                fprintf(fid, '%dx%d matrix values */\n', field_size(1), field_size(2));
                for row = 1:field_size(1)
                    fprintf(fid, '    ');
                    fprintf(fid, '%g, ', field_data(row, :));
                    fprintf(fid, '\n');
                end
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '%s array values */\n', mat2str(field_size));
                fprintf(fid, '    ');
                fprintf(fid, '%g, ', field_data(:)');
                fprintf(fid, '\n');
            end
            
            % Add a blank line between fields for better readability
            if i < length(field_names)
                fprintf(fid, '\n');
            end
        end
        
    % Close the array
    fprintf(fid, '    };\n\n');

    % set the default parameter values
    fprintf(fid, '    // Set the MPC config\n');
    fprintf(fid, '    // It have to be static because only then all other values and pointer are set to zero!\n');
    fprintf(fid, ['    static mpc_config_t ', func_name, 'Config = {\n']);
    fprintf(fid, '        .kinematic_mpc = %s_KINEMATIC_MPC, // Kinematic MPC (u_opt=q0_pp, x1, q1pp) or dynamic MPC (u_opt=tau0)\n', func_name);
    fprintf(fid, '        .traj_data_per_horizon = %s_TRAJ_DATA_PER_HORIZON, // Number of trajectory data points per horizon\n', func_name);
    fprintf(fid, '        .traj_indices = %s_TRAJ_INDICES, // Local indices of the trajectory per horizon\n', func_name);
    fprintf(fid, '        .N_step = %s_N_STEP, // Number of Control frequency stepswidth in the prediction horizon\n', func_name);
    fprintf(fid, '        .param_weight = %s_param_weight, // Parameter weights\n', func_name);
    fprintf(fid, '        .param_weight_len = %s_PARAM_WEIGHT_LEN, // Length of the parameter weights\n', func_name);
    fprintf(fid, '        .casadi_fun = &%s, // CasADi function\n', func_name);
    fprintf(fid, '        .arg = arg, // Arguments for the CasADi function\n');
    fprintf(fid, '        .res = res, // Results from the CasADi function\n');
    fprintf(fid, '        .iw = iw, // Integer workspace for the CasADi function\n');
    fprintf(fid, '        .w = w, // Real workspace for the CasADi function\n');
    fprintf(fid, '        .w_end = w+%s_W_END_ADDR, // Address of the end of the workspace\n', func_name);
    fprintf(fid, '        .arg_indices = %s_ARG, // Argument indices for the CasADi function\n', func_name);
    fprintf(fid, '        .res_indices = %s_RES, // Result indices for the CasADi function\n', func_name);
    fprintf(fid, '        .arg_in_len = %s_ARG_IN_LEN, // Length of the input arguments\n', func_name);
    fprintf(fid, '        .res_out_len = %s_RES_OUT_LEN, // Length of the output results\n', func_name);
    fprintf(fid, '        .mem = 0, // Memory\n');
    fprintf(fid, '        .set_init_guess_out_to_in = &set_init_guess_out_to_in_%s, // Setter function for updating init guess\n', func_name);
    fprintf(fid, '        .set_prev_to_out = &set_prev_to_out_%s, // Setter function for previous to output\n', func_name);
    fprintf(fid, '        .in = {\n');
    
    for i = 1:length(casadi_fun_input_cell)
        input_cell = casadi_fun_input_cell{i};
        for j = 1:length(input_cell)
            dim = input_cell{j}.dim;
            name = input_cell{j}.name;

            % .x_k = {
            %         .ptr = w+MPC6_X_K_ADDR,
            %         .len = MPC6_X_K_LEN,
            %         .fun = &set_MPC6_x_k,
            %         .id = MPC_x_k,
            %   }

            create_mpc_inout_entry(fid, func_name, name, dim, 'set', false);
        end
    end

    % Extra setter functions for reference_values, init_guess, and param_weight
    for i = 1:length(extra_input_entries.names)
        create_mpc_inout_entry(fid, func_name, extra_input_entries.names{i}, extra_input_entries.dim_text{i}, 'set', i == length(extra_input_entries.names));
    end
    
    fprintf(fid, '       },\n');

    fprintf(fid, '       .out = {\n');
    for i = 1:length(casadi_fun_output_cell)
        output_cell = casadi_fun_output_cell{i};
        for j = 1:length(output_cell)
            dim = output_cell{j}.dim;
            name = output_cell{j}.name;

            % .u_out_addr = {
            %     .ptr = MPC6_U_OUT_ADDR,
            %     .len = MPC6_U_OUT_LEN,
            %     .fun = &get_MPC6_u_out,
            %     .id = MPC_u_out,
            % }
            create_mpc_inout_entry(fid, func_name, name, dim, 'get', false);
        end
    end

    % extra getter for init_guess_out
    create_mpc_inout_entry(fid, func_name, 'init_guess_out', "", 'get', true);

    fprintf(fid, '       }\n');
    fprintf(fid, '   };\n');
    fprintf(fid, '   return %sConfig;\n', func_name);
    fprintf(fid, '}\n');

    % Close the file
    fclose(fid);

    % check whether file changed
    if ~exist(output_file_fin, 'file') || ~isequal(fileread(output_file), fileread(output_file_fin))
        % Rename the temporary file to the final file
        movefile(output_file, output_file_fin);
        fprintf(2, 'Source file %s has been created successfully.\n', param_weight_source_name);
    else
        % Delete the temporary file
        delete(output_file);
        fprintf('Source file %s unchanged.\n', param_weight_source_name);
    end

    
end

function create_mpc_inout_entry(fid, func_name, name, dim, funstr, last)
    arguments
        fid;
        func_name;
        name;
        dim = "";
        funstr = 'set';
        last = false;
    end

    fprintf(fid, '            .%s = {', name);

    if(size(dim, 2) > 0)
        if length(dim) == 2 && all(dim > 1)
            % It's a matrix
            fprintf(fid, '        /*%s: %dx%d matrix values */\n', name, dim(1), dim(2));
        else
            % It's a vector or higher dimensional array
            fprintf(fid, '        /*%s: %s array values */\n', name, mat2str(dim));
        end
    elseif(ischar(dim))
        fprintf(fid, '        /*%s: %s */\n', name, dim);
    end

    fprintf(fid, '                .ptr = w+%s_%s_ADDR,\n', func_name, upper(name));
    fprintf(fid, '                .len = %s_%s_LEN,\n', func_name, upper(name));
    fprintf(fid, '                .%s = &%s_%s_%s,\n', funstr, funstr, func_name, name);
    fprintf(fid, '                .id = (casadi_uint) MPC_%s,\n', name);
    if last
        fprintf(fid, '            }\n');
    else
        fprintf(fid, '            },\n');
    end
end

function generate_set_get_functions(fid, func_name, prestring, casadi_fun_cell, set)
    for i = 1:length(casadi_fun_cell)
        input_cell = casadi_fun_cell{i};
        
        for j = 1:length(input_cell)
            dim = input_cell{j}.dim;
            name = input_cell{j}.name;
            
            % Write the function definition
            fprintf(fid, 'void %s_%s_%s(casadi_real *const w, casadi_real *const %s) {\n', prestring, func_name, name, name);
            
            if(set)
                % Write the memcpy statement
                fprintf(fid, '    memcpy(w + %s_%s_ADDR, %s, %s_%s_LEN * sizeof(casadi_real));', ...
                        func_name, upper(name), name, func_name, upper(name));
            else
                % Write the memcpy statement
                fprintf(fid, '    memcpy(%s, w + %s_%s_ADDR, %s_%s_LEN * sizeof(casadi_real));', ...
                    name, func_name, upper(name), func_name, upper(name));
            end
            
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '\t/* %s: %dx%d matrix values */\n', name, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '\t/* %s: %s array values */\n', name, mat2str(dim));
            end
            
            fprintf(fid, '}\n');
        end
    end
end

function generate_prev_to_out_functions(fid, prestring, casadi_fun_input_cell, casadi_fun_output_cell, func_name)
    for i = 1:length(casadi_fun_input_cell)
        input_cell = casadi_fun_input_cell{i};
        output_cell = casadi_fun_output_cell{i};
        for j = 1:length(input_cell)
            dim = input_cell{j}.dim;
            name_in = input_cell{j}.name;
            name_out = output_cell{j}.name;
                
            % Write the function definition
            fprintf(fid, 'void %s_%s_to_%s_%s(casadi_real *const w) { \n', prestring, name_in, name_out, func_name);
            
            % Write the memcpy statement
            fprintf(fid, '    memcpy(w + %s_%s_ADDR, w + %s_%s_ADDR, %s_%s_LEN * sizeof(casadi_real));', ...
                    func_name, upper(name_in), func_name, upper(name_out), func_name, upper(name_out));
            
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '\t/* %s: %dx%d matrix values */\n', name_in, dim(1), dim(2));
            else
                % It's a vector or higher dimensional array
                fprintf(fid, '\t/* %s: %s array values */\n', name_in, mat2str(dim));
            end
            
            fprintf(fid, '}\n');
        end
    end
end

function generate_function_declarations(fid, prestring, casadi_fun_input_cell, func_name)
    % Generates C-style function declarations for CasADi functions
    %
    % Inputs:
    %   fid - File identifier (use fopen to create or open a file)
    %   casadi_fun_input_cell - Cell array containing input data structures
    %                           Each structure must have fields:
    %                           - dim: Dimensions of the variable (e.g., [3, 3])
    %                           - name: Name of the variable (e.g., 'A')
    %   func_name - Name of the function to use in the generated declarations
    %
    % Example usage:
    %   fid = fopen('output.c', 'w');
    %   casadi_fun_input_cell = {
    %       {struct('dim', [3, 3], 'name', 'A'), struct('dim', [4, 1], 'name', 'B')}, ...
    %       {struct('dim', [2, 2], 'name', 'C')}
    %   };
    %   func_name = 'my_function';
    %   generate_function_declarations(fid, casadi_fun_input_cell, func_name);
    %   fclose(fid);

    for i = 1:length(casadi_fun_input_cell)
        input_cell = casadi_fun_input_cell{i};
        for j = 1:length(input_cell)
            dim = input_cell{j}.dim;
            name = input_cell{j}.name;

            % Write the function declaration
            fprintf(fid, 'void %s_%s_%s(casadi_real *const w, casadi_real *const %s);', prestring, func_name, name, name);

            % Add a comment describing the dimensions
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /* %s %s: %dx%d matrix values */\n', prestring, name, dim(1), dim(2));
            else
                % It's a vector or higher-dimensional array
                fprintf(fid, '        /* %s %s: %s array values */\n', prestring, name, mat2str(dim));
            end
        end
    end
end


function generate_prev_to_out_declarations(fid, prestring, casadi_fun_input_cell, casadi_fun_output_cell, func_name)
    for i = 1:length(casadi_fun_input_cell)
        input_cell = casadi_fun_input_cell{i};
        output_cell = casadi_fun_output_cell{i};
        for j = 1:length(input_cell)
            dim = input_cell{j}.dim;
            name_in = input_cell{j}.name;
            name_out = output_cell{j}.name;

            % Write the function declaration
            fprintf(fid, 'void %s_%s_to_%s_%s(casadi_real *const w);', prestring, name_in, name_out, func_name);

            % Add a comment describing the dimensions
            if length(dim) == 2 && all(dim > 1)
                % It's a matrix
                fprintf(fid, '        /* %s %s: %dx%d matrix values */\n', prestring, name_in, dim(1), dim(2));
            else
                % It's a vector or higher-dimensional array
                fprintf(fid, '        /* %s %s: %s array values */\n', prestring, name_in, mat2str(dim));
            end
        end
    end
end
%implements s9_b0_hij8o_Functions "C"

%function cartesian_impedance_con_vecnorm_Fcn0(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
for ( int32_T j = 0; j < 2; j++) {
    real_T b_y;
    real_T scale;
    int32_T ix0;
    ix0 = (j << 1) + 1;
    b_y = 0.0;
    scale = 3.3121686421112381E-170;
    for ( int32_T k = ix0; k <= ix0 + 1; k++) {
        real_T absxk;
        absxk = fabs(x[k - 1]);
        if (absxk > scale) {
            real_T t;
            t = scale / absxk;
            b_y = b_y * t * t + 1.0;
            scale = absxk;
        } else {
            real_T t;
            t = absxk / scale;
            b_y += t * t;
        }
    }
    y[j] = scale * sqrt(b_y);
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void cartesian_impedance_con_vecnorm(\
%assign comma = ""
%<comma>const real_T x[4]\
%assign comma = ", "
%<comma>real_T y[2]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 0, fcnProtoType)>
%return fcnBuff
%endfunction

%function cartesian_impedance_contr_xnrm2_Fcn1(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T absxk;
real_T scale;
real_T t;
real_T y;
scale = 3.3121686421112381E-170;
absxk = fabs(x[0]);
if (absxk > 3.3121686421112381E-170) {
    y = 1.0;
    scale = absxk;
} else {
    t = absxk / 3.3121686421112381E-170;
    y = t * t;
}
absxk = fabs(x[1]);
if (absxk > scale) {
    t = scale / absxk;
    y = y * t * t + 1.0;
    scale = absxk;
} else {
    t = absxk / scale;
    y += t * t;
}
return scale * sqrt(y);
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static real_T cartesian_impedance_contr_xnrm2(\
%assign comma = ""
%<comma>const real_T x[4]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 1, fcnProtoType)>
%return fcnBuff
%endfunction

%function cartesian_impedance_contr_xdotc_Fcn2(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
return x[0] * y[2] + x[1] * y[3];
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static real_T cartesian_impedance_contr_xdotc(\
%assign comma = ""
%<comma>const real_T x[4]\
%assign comma = ", "
%<comma>const real_T y[4]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 2, fcnProtoType)>
%return fcnBuff
%endfunction

%function cartesian_impedance_contr_xaxpy_Fcn3(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
if (!(a == 0.0)) {
    y[2] += a * y[0];
    y[3] += a * y[1];
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void cartesian_impedance_contr_xaxpy(\
%assign comma = ""
%<comma>real_T a\
%assign comma = ", "
%<comma>real_T y[4]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 3, fcnProtoType)>
%return fcnBuff
%endfunction

%function cartesian_impedance_contr_xswap_Fcn4(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T temp;
temp = x[0];
x[0] = x[2];
x[2] = temp;
temp = x[1];
x[1] = x[3];
x[3] = temp;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void cartesian_impedance_contr_xswap(\
%assign comma = ""
%<comma>real_T x[4]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 4, fcnProtoType)>
%return fcnBuff
%endfunction

%function cartesian_impedance_contr_xrotg_Fcn5(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T absa;
real_T absb;
real_T roe;
real_T scale;
roe = *b;
absa = fabs(*a);
absb = fabs(*b);
if (absa > absb) {
    roe = *a;
}
scale = absa + absb;
if (scale == 0.0) {
    *s = 0.0;
    *c = 1.0;
    *a = 0.0;
    *b = 0.0;
} else {
    real_T ads;
    real_T bds;
    ads = absa / scale;
    bds = absb / scale;
    scale *= sqrt(ads * ads + bds * bds);
    if (roe < 0.0) {
        scale = -scale;
    }
    *c = *a / scale;
    *s = *b / scale;
    if (absa > absb) {
        *b = *s;
    } else if (*c != 0.0) {
        *b = 1.0 / *c;
    } else {
        *b = 1.0;
    }
    *a = scale;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void cartesian_impedance_contr_xrotg(\
%assign comma = ""
%<comma>real_T *a\
%assign comma = ", "
%<comma>real_T *b\
%assign comma = ", "
%<comma>real_T *c\
%assign comma = ", "
%<comma>real_T *s\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 5, fcnProtoType)>
%return fcnBuff
%endfunction

%function cartesian_impedance_contr_svd_b_Fcn6(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T b_A[4];
real_T b_s[2];
real_T e[2];
real_T nrm;
real_T r;
real_T rt;
real_T sqds;
real_T temp;
int32_T iter;
int32_T m;
int32_T q;
int32_T qs;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,6,10,0)
%<SLibCG_AccessArg(0 ,6, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,6,9,0)
%<SLibCG_AccessArg(0 ,6, 3)>
%endif

%if SLibCG_FcnCallArgAccessed(0,6,4,1)
%<SLibCG_AccessArg(0 ,6, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,6,3,0)
%<SLibCG_AccessArg(0 ,6, 1)>
%endif
%if SLibCG_FcnCallArgAccessed(0,6,3,1)
%<SLibCG_AccessArg(0 ,6, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,6,0,0)
%<SLibCG_AccessArg(0 ,6, 0)>
%endif

b_A[0] = A[0];
b_A[1] = A[1];
b_A[2] = A[2];
b_A[3] = A[3];
nrm = %<(SLibCGCallSubFcn("cartesian_impedance_contr_xnrm2", ["A"], 0, 6, 0))>;
if (nrm > 0.0) {
    if (A[0] < 0.0) {
        b_s[0] = -nrm;
    } else {
        b_s[0] = nrm;
    }
    if (fabs(b_s[0]) >= 1.0020841800044864E-292) {
        nrm = 1.0 / b_s[0];
        b_A[0] = nrm * A[0];
        b_A[1] = nrm * A[1];
    } else {
        b_A[0] = A[0] / b_s[0];
        b_A[1] = A[1] / b_s[0];
    }
    b_A[0]++;
    b_s[0] = -b_s[0];
    %<(SLibCGCallSubFcn("cartesian_impedance_contr_xaxpy", ["-(%<(SLibCGCallSubFcn("cartesian_impedance_contr_xdotc", ["b_A", "b_A"], 0, 6, 1))> / b_A[0])", "b_A"], 0, 6, 2))>;
} else {
    b_s[0] = 0.0;
}
m = 2;
b_s[1] = b_A[3];
e[0] = b_A[2];
e[1] = 0.0;
U[0] = b_A[0];
U[2] = 0.0;
U[1] = b_A[1];
U[3] = 1.0;
if (b_s[0] != 0.0) {
    %<(SLibCGCallSubFcn("cartesian_impedance_contr_xaxpy", ["-(%<(SLibCGCallSubFcn("cartesian_impedance_contr_xdotc", ["U", "U"], 0, 6, 3))> / b_A[0])", "U"], 0, 6, 4))>;
    U[1] = -U[1];
    U[0] = -U[0] + 1.0;
} else {
    U[1] = 0.0;
    U[0] = 1.0;
}
V[2] = 0.0;
V[3] = 1.0;
V[1] = 0.0;
V[0] = 1.0;
for (q = 0; q < 2; q++) {
    nrm = e[0];
    if (b_s[q] != 0.0) {
        rt = fabs(b_s[q]);
        r = b_s[q] / rt;
        b_s[q] = rt;
        if (q + 1 < 2) {
            nrm = e[0] / r;
        }
        iter = (q << 1) + 1;
        for (qs = iter; qs <= iter + 1; qs++) {
            U[qs - 1] *= r;
        }
    }
    if ((q + 1 < 2) && (nrm != 0.0)) {
        rt = fabs(nrm);
        r = rt / nrm;
        nrm = rt;
        b_s[1] *= r;
        V[2] *= r;
        V[3] *= r;
    }
    e[0] = nrm;
}
iter = 0;
nrm = fmax(fmax(0.0, fmax(fabs(b_s[0]), fabs(e[0]))), fmax(fabs(b_s[1]), 0.0));
while ((m > 0) && (iter < 75)) {
    int32_T kase;
    boolean_T exitg1;
    q = m - 1;
    exitg1 = false;
    while (!(exitg1 || (q == 0))) {
        rt = fabs(e[0]);
        if ((rt <= (fabs(b_s[0]) + fabs(b_s[1])) * 2.2204460492503131E-16) || ((rt <= 1.0020841800044864E-292) || ((iter > 20) && (rt <= 2.2204460492503131E-16 * nrm)))) {
            e[0] = 0.0;
            exitg1 = true;
        } else {
            q = 0;
        }
    }
    if (m - 1 == q) {
        kase = 4;
    } else {
        qs = m;
        kase = m;
        exitg1 = false;
        while ((!exitg1) && (kase >= q)) {
            qs = kase;
            if (kase == q) {
                exitg1 = true;
            } else {
                rt = 0.0;
                if (kase < m) {
                    rt = fabs(e[0]);
                }
                if (kase > q + 1) {
                    rt += fabs(e[0]);
                }
                r = fabs(b_s[kase - 1]);
                if ((r <= 2.2204460492503131E-16 * rt) || (r <= 1.0020841800044864E-292)) {
                    b_s[kase - 1] = 0.0;
                    exitg1 = true;
                } else {
                    kase--;
                }
            }
        }
        if (qs == q) {
            kase = 3;
        } else if (qs == m) {
            kase = 1;
        } else {
            kase = 2;
            q = qs;
        }
    }
    switch (kase) {
      case 1: {
        rt = e[0];
        e[0] = 0.0;
        for (qs = m - 1; qs >= q + 1; qs--) {
            real_T emm1;
            %<(SLibCGCallSubFcn("cartesian_impedance_contr_xrotg", ["&b_s[0]", "&rt", "&r", "&sqds"], 0, 6, 8))>;
            kase = (m - 1) << 1;
            temp = r * V[0] + sqds * V[kase];
            V[kase] = r * V[kase] - sqds * V[0];
            V[0] = temp;
            emm1 = V[kase + 1];
            temp = emm1 * sqds + r * V[1];
            V[kase + 1] = emm1 * r - sqds * V[1];
            V[1] = temp;
        }
}
        break;
      case 2: {
        rt = e[q - 1];
        e[q - 1] = 0.0;
        for (qs = q + 1; qs <= m; qs++) {
            real_T emm1;
            int32_T b_iy;
            %<(SLibCGCallSubFcn("cartesian_impedance_contr_xrotg", ["&b_s[qs - 1]", "&rt", "&r", "&sqds"], 0, 6, 7))>;
            temp = e[qs - 1];
            rt = temp * -sqds;
            e[qs - 1] = temp * r;
            kase = (qs - 1) << 1;
            b_iy = (q - 1) << 1;
            temp = r * U[kase] + sqds * U[b_iy];
            U[b_iy] = r * U[b_iy] - sqds * U[kase];
            U[kase] = temp;
            temp = U[b_iy + 1];
            emm1 = U[kase + 1];
            U[b_iy + 1] = temp * r - emm1 * sqds;
            U[kase + 1] = emm1 * r + temp * sqds;
        }
}
        break;
      case 3: {
        real_T emm1;
        real_T shift;
        rt = b_s[m - 1];
        r = fmax(fmax(fmax(fmax(fabs(rt), fabs(b_s[0])), fabs(e[0])), fabs(b_s[q])), fabs(e[q]));
        rt /= r;
        temp = b_s[0] / r;
        emm1 = e[0] / r;
        sqds = b_s[q] / r;
        temp = ((temp + rt) * (temp - rt) + emm1 * emm1) / 2.0;
        emm1 *= rt;
        emm1 *= emm1;
        if ((temp != 0.0) || (emm1 != 0.0)) {
            shift = sqrt(temp * temp + emm1);
            if (temp < 0.0) {
                shift = -shift;
            }
            shift = emm1 / (temp + shift);
        } else {
            shift = 0.0;
        }
        rt = (sqds + rt) * (sqds - rt) + shift;
        r = e[q] / r * sqds;
        for (qs = q + 1; qs < 2; qs++) {
            %<(SLibCGCallSubFcn("cartesian_impedance_contr_xrotg", ["&rt", "&r", "&sqds", "&temp"], 0, 6, 5))>;
            rt = sqds * b_s[0] + temp * e[0];
            e[0] = sqds * e[0] - temp * b_s[0];
            r = temp * b_s[1];
            b_s[1] *= sqds;
            emm1 = sqds * V[0] + temp * V[2];
            V[2] = sqds * V[2] - temp * V[0];
            V[0] = emm1;
            emm1 = sqds * V[1] + temp * V[3];
            V[3] = sqds * V[3] - temp * V[1];
            V[1] = emm1;
            b_s[0] = rt;
            %<(SLibCGCallSubFcn("cartesian_impedance_contr_xrotg", ["&b_s[0]", "&r", "&sqds", "&temp"], 0, 6, 6))>;
            rt = sqds * e[0] + temp * b_s[1];
            b_s[1] = -temp * e[0] + sqds * b_s[1];
            r = temp * e[1];
            e[1] *= sqds;
            emm1 = sqds * U[0] + temp * U[2];
            U[2] = sqds * U[2] - temp * U[0];
            U[0] = emm1;
            emm1 = sqds * U[1] + temp * U[3];
            U[3] = sqds * U[3] - temp * U[1];
            U[1] = emm1;
        }
        e[0] = rt;
        iter++;
}
        break;
      default:
        if (b_s[q] < 0.0) {
            b_s[q] = -b_s[q];
            iter = (q << 1) + 1;
            for (qs = iter; qs <= iter + 1; qs++) {
                V[qs - 1] = -V[qs - 1];
            }
        }
        while ((q + 1 < 2) && (b_s[0] < b_s[1])) {
            rt = b_s[0];
            b_s[0] = b_s[1];
            b_s[1] = rt;
            %<(SLibCGCallSubFcn("cartesian_impedance_contr_xswap", ["V"], 0, 6, 9))>;
            %<(SLibCGCallSubFcn("cartesian_impedance_contr_xswap", ["U"], 0, 6, 10))>;
            q = 1;
        }
        iter = 0;
        m--;
        break;
    }
}
s[0] = b_s[0];
s[1] = b_s[1];
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void cartesian_impedance_contr_svd_b(\
%assign comma = ""
%<comma>const real_T A[4]\
%assign comma = ", "
%<comma>real_T U[4]\
%assign comma = ", "
%<comma>real_T s[2]\
%assign comma = ", "
%<comma>real_T V[4]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 6, fcnProtoType)>
%return fcnBuff
%endfunction

%function cartesian_impedance_control_svd_Fcn7(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T s[2];
boolean_T p;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,7,0,0)
%<SLibCG_AccessArg(0 ,7, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,7,0,1)
%<SLibCG_AccessArg(0 ,7, 1)>
%endif
%if SLibCG_FcnCallArgAccessed(0,7,0,3)
%<SLibCG_AccessArg(0 ,7, 3)>
%endif

p = true;
if (rtIsInf(A[0]) || rtIsNaN(A[0])) {
    p = false;
}
if (p && ((!rtIsInf(A[1])) && (!rtIsNaN(A[1])))) {
} else {
    p = false;
}
if (p && ((!rtIsInf(A[2])) && (!rtIsNaN(A[2])))) {
} else {
    p = false;
}
if (p && ((!rtIsInf(A[3])) && (!rtIsNaN(A[3])))) {
} else {
    p = false;
}
if (p) {
    %<(SLibCGCallSubFcn("cartesian_impedance_contr_svd_b", ["A", "U", "s", "V"], 0, 7, 0))>;
} else {
    U[0] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    U[1] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    U[2] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    U[3] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    s[0] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    s[1] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    V[0] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    V[1] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    V[2] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    V[3] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
}
S[1] = 0.0;
S[2] = 0.0;
S[0] = s[0];
S[3] = s[1];
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void cartesian_impedance_control_svd(\
%assign comma = ""
%<comma>const real_T A[4]\
%assign comma = ", "
%<comma>real_T U[4]\
%assign comma = ", "
%<comma>real_T S[4]\
%assign comma = ", "
%<comma>real_T V[4]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 7, fcnProtoType)>
%return fcnBuff
%endfunction

%function rt_hypotd_snf_Fcn8(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T a;
real_T b;
real_T y;
a = fabs(u0);
b = fabs(u1);
if (a < b) {
    a /= b;
    y = sqrt(a * a + 1.0) * b;
} else if (a > b) {
    b /= a;
    y = sqrt(b * b + 1.0) * a;
} else if (rtIsNaN(b)) {
    y = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
} else {
    y = a * 1.4142135623730951;
}
return y;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
extern real_T rt_hypotd_snf(\
%assign comma = ""
%<comma>real_T u0\
%assign comma = ", "
%<comma>real_T u1\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 8, fcnProtoType)>
%return fcnBuff
%endfunction

%function cartesian_impedance__mldivide_p_Fcn9(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T B[4];
real_T b_A_data[2];
real_T b_Y_data[2];
static const int8_T b_B[4] = %<(TLC_STR_CTX(0))>;
if (A_size[1] == 0) {
    Y_size[0] = 0;
    Y_size[1] = 2;
} else if (A_size[1] == 2) {
    real_T B_tmp;
    real_T tau_data_idx_0;
    real_T wj;
    real_T wj_tmp;
    real_T xnorm;
    int32_T knt;
    int32_T rankA;
    if (fabs(A_data[1]) > fabs(A_data[0])) {
        rankA = 1;
        knt = 0;
    } else {
        rankA = 0;
        knt = 1;
    }
    wj_tmp = A_data[rankA];
    wj = A_data[knt] / wj_tmp;
    tau_data_idx_0 = A_data[rankA + 2];
    xnorm = A_data[knt + 2] - wj * tau_data_idx_0;
    B_tmp = b_B[rankA];
    B[1] = (static_cast<real_T>(b_B[knt]) - B_tmp * wj) / xnorm;
    B[0] = (B_tmp - B[1] * tau_data_idx_0) / wj_tmp;
    B_tmp = b_B[rankA + 2];
    B[3] = (static_cast<real_T>(b_B[knt + 2]) - B_tmp * wj) / xnorm;
    B[2] = (B_tmp - B[3] * tau_data_idx_0) / wj_tmp;
    Y_size[0] = 2;
    Y_size[1] = 2;
    Y_data[0] = B[0];
    Y_data[1] = B[1];
    Y_data[2] = B[2];
    Y_data[3] = B[3];
} else {
    real_T tau_data_idx_0;
    real_T wj;
    real_T wj_tmp;
    real_T xnorm;
    int32_T knt;
    int32_T rankA;
    for (knt = 0; knt < 2; knt++) {
        wj = A_data[knt];
        b_Y_data[knt] = wj;
        b_A_data[knt] = wj;
    }
    wj = b_A_data[0];
    tau_data_idx_0 = 0.0;
    xnorm = fabs(b_A_data[1]);
    if (xnorm != 0.0) {
        xnorm = %<(SLibCGCallSubFcn("rt_hypotd_snf", ["b_A_data[0]", "xnorm"], 0, 9, 0))>;
        if (b_A_data[0] >= 0.0) {
            xnorm = -xnorm;
        }
        if (fabs(xnorm) < 1.0020841800044864E-292) {
            knt = 0;
            do {
                knt++;
                b_Y_data[1] *= 9.9792015476736E+291;
                xnorm *= 9.9792015476736E+291;
                wj *= 9.9792015476736E+291;
            } while ((fabs(xnorm) < 1.0020841800044864E-292) && (knt < 20));
            xnorm = %<(SLibCGCallSubFcn("rt_hypotd_snf", ["wj", "fabs(b_Y_data[1])"], 0, 9, 1))>;
            if (wj >= 0.0) {
                xnorm = -xnorm;
            }
            tau_data_idx_0 = (xnorm - wj) / xnorm;
            b_Y_data[1] *= 1.0 / (wj - xnorm);
            for (rankA = 0; rankA < knt; rankA++) {
                xnorm *= 1.0020841800044864E-292;
            }
            wj = xnorm;
        } else {
            tau_data_idx_0 = (xnorm - b_A_data[0]) / xnorm;
            b_Y_data[1] *= 1.0 / (b_A_data[0] - xnorm);
            wj = xnorm;
        }
    }
    for (knt = 0; knt < 2; knt++) {
        b_A_data[knt] = b_Y_data[knt];
    }
    b_A_data[0] = wj;
    rankA = 0;
    wj_tmp = b_A_data[0];
    wj = fabs(wj_tmp);
    if (!(wj <= 4.4408920985006262E-15 * wj)) {
        rankA = 1;
    }
    b_Y_data[0] = 0.0;
    b_Y_data[1] = 0.0;
    B[0] = 1.0;
    B[1] = 0.0;
    B[2] = 0.0;
    B[3] = 1.0;
    if (tau_data_idx_0 != 0.0) {
        xnorm = b_A_data[1];
        wj = (xnorm * 0.0 + 1.0) * tau_data_idx_0;
        if (wj != 0.0) {
            B[0] = 1.0 - wj;
            B[1] = 0.0 - xnorm * wj;
        }
        wj = tau_data_idx_0 * xnorm;
        if (wj != 0.0) {
            B[2] = 0.0 - wj;
            B[3] = 1.0 - b_A_data[1] * wj;
        }
    }
    for (knt = 0; knt < 2; knt++) {
        if (rankA - 1 >= 0) {
            b_Y_data[knt] = B[knt << 1];
        }
        for ( int32_T j = rankA; j >= 1; j--) {
            b_Y_data[knt] /= wj_tmp;
        }
    }
    Y_size[0] = 1;
    Y_size[1] = 2;
    for (knt = 0; knt < 2; knt++) {
        Y_data[knt] = b_Y_data[knt];
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void cartesian_impedance__mldivide_p(\
%assign comma = ""
%<comma>const real_T A_data[]\
%assign comma = ", "
%<comma>const int32_T A_size[2]\
%assign comma = ", "
%<comma>real_T Y_data[]\
%assign comma = ", "
%<comma>int32_T Y_size[2]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 9, fcnProtoType)>
%return fcnBuff
%endfunction

%function cartesian_impedance__local_rank_Fcn10(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T b_s[2];
real_T s[2];
real_T nrm;
real_T r;
real_T smm1;
real_T ztest0;
int32_T irank;
int32_T m;
boolean_T p;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,10,0,0)
%<SLibCG_AccessArg(0 ,10, 0)>
%endif

irank = 0;
p = true;
if (rtIsInf(A[0]) || rtIsNaN(A[0])) {
    p = false;
}
if (p && ((!rtIsInf(A[1])) && (!rtIsNaN(A[1])))) {
} else {
    p = false;
}
if (p && ((!rtIsInf(A[2])) && (!rtIsNaN(A[2])))) {
} else {
    p = false;
}
if (p && ((!rtIsInf(A[3])) && (!rtIsNaN(A[3])))) {
} else {
    p = false;
}
if (p) {
    real_T snorm;
    int32_T iter;
    snorm = A[2];
    ztest0 = A[3];
    nrm = %<(SLibCGCallSubFcn("cartesian_impedance_contr_xnrm2", ["A"], 0, 10, 0))>;
    if (nrm > 0.0) {
        if (A[0] < 0.0) {
            b_s[0] = -nrm;
        } else {
            b_s[0] = nrm;
        }
        if (fabs(b_s[0]) >= 1.0020841800044864E-292) {
            r = 1.0 / b_s[0];
            nrm = r * A[0];
            r *= A[1];
        } else {
            nrm = A[0] / b_s[0];
            r = A[1] / b_s[0];
        }
        nrm++;
        b_s[0] = -b_s[0];
        smm1 = -((nrm * A[2] + r * A[3]) / nrm);
        if (!(smm1 == 0.0)) {
            snorm = smm1 * nrm + A[2];
            ztest0 = smm1 * r + A[3];
        }
    } else {
        b_s[0] = 0.0;
    }
    m = 2;
    b_s[1] = ztest0;
    s[1] = 0.0;
    if (b_s[0] != 0.0) {
        nrm = fabs(b_s[0]);
        r = b_s[0] / nrm;
        b_s[0] = nrm;
        snorm /= r;
    }
    if (snorm != 0.0) {
        nrm = fabs(snorm);
        r = nrm / snorm;
        snorm = nrm;
        b_s[1] = ztest0 * r;
    }
    if (b_s[1] != 0.0) {
        b_s[1] = fabs(b_s[1]);
    }
    s[0] = snorm;
    iter = 0;
    snorm = fmax(fmax(b_s[0], snorm), fmax(b_s[1], 0.0));
    while ((m > 0) && (iter < 75)) {
        int32_T kase;
        int32_T q;
        int32_T qs;
        boolean_T exitg1;
        q = m - 1;
        exitg1 = false;
        while (!(exitg1 || (q == 0))) {
            ztest0 = fabs(s[0]);
            if ((ztest0 <= (fabs(b_s[0]) + fabs(b_s[1])) * 2.2204460492503131E-16) || ((ztest0 <= 1.0020841800044864E-292) || ((iter > 20) && (ztest0 <= 2.2204460492503131E-16 * snorm)))) {
                s[0] = 0.0;
                exitg1 = true;
            } else {
                q = 0;
            }
        }
        if (m - 1 == q) {
            kase = 4;
        } else {
            qs = m;
            kase = m;
            exitg1 = false;
            while ((!exitg1) && (kase >= q)) {
                qs = kase;
                if (kase == q) {
                    exitg1 = true;
                } else {
                    ztest0 = 0.0;
                    if (kase < m) {
                        ztest0 = fabs(s[0]);
                    }
                    if (kase > q + 1) {
                        ztest0 += fabs(s[0]);
                    }
                    nrm = fabs(b_s[kase - 1]);
                    if ((nrm <= 2.2204460492503131E-16 * ztest0) || (nrm <= 1.0020841800044864E-292)) {
                        b_s[kase - 1] = 0.0;
                        exitg1 = true;
                    } else {
                        kase--;
                    }
                }
            }
            if (qs == q) {
                kase = 3;
            } else if (qs == m) {
                kase = 1;
            } else {
                kase = 2;
                q = qs;
            }
        }
        switch (kase) {
          case 1:
            ztest0 = s[0];
            s[0] = 0.0;
            for (qs = m - 1; qs >= q + 1; qs--) {
                %<(SLibCGCallSubFcn("cartesian_impedance_contr_xrotg", ["&b_s[0]", "&ztest0", "&nrm", "&r"], 0, 10, 4))>;
            }
            break;
          case 2:
            ztest0 = s[q - 1];
            s[q - 1] = 0.0;
            for (qs = q + 1; qs <= m; qs++) {
                %<(SLibCGCallSubFcn("cartesian_impedance_contr_xrotg", ["&b_s[qs - 1]", "&ztest0", "&nrm", "&r"], 0, 10, 3))>;
                smm1 = s[qs - 1];
                ztest0 = smm1 * -r;
                s[qs - 1] = smm1 * nrm;
            }
            break;
          case 3: {
            real_T emm1;
            real_T shift;
            ztest0 = b_s[m - 1];
            nrm = fmax(fmax(fmax(fmax(fabs(ztest0), fabs(b_s[0])), fabs(s[0])), fabs(b_s[q])), fabs(s[q]));
            ztest0 /= nrm;
            smm1 = b_s[0] / nrm;
            emm1 = s[0] / nrm;
            r = b_s[q] / nrm;
            smm1 = ((smm1 + ztest0) * (smm1 - ztest0) + emm1 * emm1) / 2.0;
            emm1 *= ztest0;
            emm1 *= emm1;
            if ((smm1 != 0.0) || (emm1 != 0.0)) {
                shift = sqrt(smm1 * smm1 + emm1);
                if (smm1 < 0.0) {
                    shift = -shift;
                }
                shift = emm1 / (smm1 + shift);
            } else {
                shift = 0.0;
            }
            ztest0 = (r + ztest0) * (r - ztest0) + shift;
            nrm = s[q] / nrm * r;
            for (qs = q + 1; qs < 2; qs++) {
                %<(SLibCGCallSubFcn("cartesian_impedance_contr_xrotg", ["&ztest0", "&nrm", "&r", "&smm1"], 0, 10, 1))>;
                ztest0 = r * b_s[0] + smm1 * s[0];
                s[0] = r * s[0] - smm1 * b_s[0];
                nrm = smm1 * b_s[1];
                b_s[1] *= r;
                b_s[0] = ztest0;
                %<(SLibCGCallSubFcn("cartesian_impedance_contr_xrotg", ["&b_s[0]", "&nrm", "&r", "&smm1"], 0, 10, 2))>;
                ztest0 = r * s[0] + smm1 * b_s[1];
                b_s[1] = -smm1 * s[0] + r * b_s[1];
                nrm = smm1 * s[1];
                s[1] *= r;
            }
            s[0] = ztest0;
            iter++;
}
            break;
          default:
            if (b_s[q] < 0.0) {
                b_s[q] = -b_s[q];
            }
            while ((q + 1 < 2) && (b_s[0] < b_s[1])) {
                nrm = b_s[0];
                b_s[0] = b_s[1];
                b_s[1] = nrm;
                q = 1;
            }
            iter = 0;
            m--;
            break;
        }
    }
    s[0] = b_s[0];
    s[1] = b_s[1];
} else {
    s[0] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    s[1] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
}
m = 0;
while ((m < 2) && (s[m] > 0.1)) {
    irank++;
    m++;
}
return irank;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static int32_T cartesian_impedance__local_rank(\
%assign comma = ""
%<comma>const real_T A[4]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 10, fcnProtoType)>
%return fcnBuff
%endfunction

%function cartesian_impedance_co_mldivide_Fcn11(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T Y_tmp;
real_T a21;
real_T a22;
real_T a22_tmp;
int32_T r1;
int32_T r2;
if (fabs(A[1]) > fabs(A[0])) {
    r1 = 1;
    r2 = 0;
} else {
    r1 = 0;
    r2 = 1;
}
a21 = A[r2] / A[r1];
a22_tmp = A[r1 + 2];
a22 = A[r2 + 2] - a22_tmp * a21;
Y[1] = (B[r2] - B[r1] * a21) / a22;
Y[0] = (B[r1] - a22_tmp * Y[1]) / A[r1];
Y_tmp = B[r1 + 2];
Y[3] = (B[r2 + 2] - Y_tmp * a21) / a22;
Y[2] = (Y_tmp - a22_tmp * Y[3]) / A[r1];
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void cartesian_impedance_co_mldivide(\
%assign comma = ""
%<comma>const real_T A[4]\
%assign comma = ", "
%<comma>const real_T B[4]\
%assign comma = ", "
%<comma>real_T Y[4]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 11, fcnProtoType)>
%return fcnBuff
%endfunction

%function cartesian_impedance_cont_svd_bw_Fcn12(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T Vf[4];
real_T b_A[4];
real_T b_s[2];
real_T e[2];
real_T nrm;
real_T r;
real_T rt;
real_T sqds;
real_T temp;
int32_T iter;
int32_T m;
int32_T q;
int32_T qs;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,12,10,0)
%<SLibCG_AccessArg(0 ,12, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,12,4,1)
%<SLibCG_AccessArg(0 ,12, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,12,3,0)
%<SLibCG_AccessArg(0 ,12, 1)>
%endif
%if SLibCG_FcnCallArgAccessed(0,12,3,1)
%<SLibCG_AccessArg(0 ,12, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,12,0,0)
%<SLibCG_AccessArg(0 ,12, 0)>
%endif

b_A[0] = A[0];
b_A[1] = A[1];
b_A[2] = A[2];
b_A[3] = A[3];
nrm = %<(SLibCGCallSubFcn("cartesian_impedance_contr_xnrm2", ["A"], 0, 12, 0))>;
if (nrm > 0.0) {
    if (A[0] < 0.0) {
        b_s[0] = -nrm;
    } else {
        b_s[0] = nrm;
    }
    if (fabs(b_s[0]) >= 1.0020841800044864E-292) {
        nrm = 1.0 / b_s[0];
        b_A[0] = nrm * A[0];
        b_A[1] = nrm * A[1];
    } else {
        b_A[0] = A[0] / b_s[0];
        b_A[1] = A[1] / b_s[0];
    }
    b_A[0]++;
    b_s[0] = -b_s[0];
    %<(SLibCGCallSubFcn("cartesian_impedance_contr_xaxpy", ["-(%<(SLibCGCallSubFcn("cartesian_impedance_contr_xdotc", ["b_A", "b_A"], 0, 12, 1))> / b_A[0])", "b_A"], 0, 12, 2))>;
} else {
    b_s[0] = 0.0;
}
m = 2;
b_s[1] = b_A[3];
e[0] = b_A[2];
e[1] = 0.0;
U[0] = b_A[0];
U[2] = 0.0;
U[1] = b_A[1];
U[3] = 1.0;
if (b_s[0] != 0.0) {
    %<(SLibCGCallSubFcn("cartesian_impedance_contr_xaxpy", ["-(%<(SLibCGCallSubFcn("cartesian_impedance_contr_xdotc", ["U", "U"], 0, 12, 3))> / b_A[0])", "U"], 0, 12, 4))>;
    U[1] = -U[1];
    U[0] = -U[0] + 1.0;
} else {
    U[1] = 0.0;
    U[0] = 1.0;
}
Vf[2] = 0.0;
Vf[3] = 1.0;
Vf[1] = 0.0;
Vf[0] = 1.0;
for (q = 0; q < 2; q++) {
    nrm = e[0];
    if (b_s[q] != 0.0) {
        rt = fabs(b_s[q]);
        r = b_s[q] / rt;
        b_s[q] = rt;
        if (q + 1 < 2) {
            nrm = e[0] / r;
        }
        iter = (q << 1) + 1;
        for (qs = iter; qs <= iter + 1; qs++) {
            U[qs - 1] *= r;
        }
    }
    if ((q + 1 < 2) && (nrm != 0.0)) {
        rt = fabs(nrm);
        r = rt / nrm;
        nrm = rt;
        b_s[1] *= r;
        Vf[2] *= r;
        Vf[3] *= r;
    }
    e[0] = nrm;
}
iter = 0;
nrm = fmax(fmax(0.0, fmax(fabs(b_s[0]), fabs(e[0]))), fmax(fabs(b_s[1]), 0.0));
while ((m > 0) && (iter < 75)) {
    int32_T kase;
    boolean_T exitg1;
    q = m - 1;
    exitg1 = false;
    while (!(exitg1 || (q == 0))) {
        rt = fabs(e[0]);
        if ((rt <= (fabs(b_s[0]) + fabs(b_s[1])) * 2.2204460492503131E-16) || ((rt <= 1.0020841800044864E-292) || ((iter > 20) && (rt <= 2.2204460492503131E-16 * nrm)))) {
            e[0] = 0.0;
            exitg1 = true;
        } else {
            q = 0;
        }
    }
    if (m - 1 == q) {
        kase = 4;
    } else {
        qs = m;
        kase = m;
        exitg1 = false;
        while ((!exitg1) && (kase >= q)) {
            qs = kase;
            if (kase == q) {
                exitg1 = true;
            } else {
                rt = 0.0;
                if (kase < m) {
                    rt = fabs(e[0]);
                }
                if (kase > q + 1) {
                    rt += fabs(e[0]);
                }
                r = fabs(b_s[kase - 1]);
                if ((r <= 2.2204460492503131E-16 * rt) || (r <= 1.0020841800044864E-292)) {
                    b_s[kase - 1] = 0.0;
                    exitg1 = true;
                } else {
                    kase--;
                }
            }
        }
        if (qs == q) {
            kase = 3;
        } else if (qs == m) {
            kase = 1;
        } else {
            kase = 2;
            q = qs;
        }
    }
    switch (kase) {
      case 1: {
        rt = e[0];
        e[0] = 0.0;
        for (qs = m - 1; qs >= q + 1; qs--) {
            real_T emm1;
            %<(SLibCGCallSubFcn("cartesian_impedance_contr_xrotg", ["&b_s[0]", "&rt", "&r", "&sqds"], 0, 12, 8))>;
            kase = (m - 1) << 1;
            temp = r * Vf[0] + sqds * Vf[kase];
            Vf[kase] = r * Vf[kase] - sqds * Vf[0];
            Vf[0] = temp;
            emm1 = Vf[kase + 1];
            temp = emm1 * sqds + r * Vf[1];
            Vf[kase + 1] = emm1 * r - sqds * Vf[1];
            Vf[1] = temp;
        }
}
        break;
      case 2: {
        rt = e[q - 1];
        e[q - 1] = 0.0;
        for (qs = q + 1; qs <= m; qs++) {
            real_T emm1;
            int32_T b_iy;
            %<(SLibCGCallSubFcn("cartesian_impedance_contr_xrotg", ["&b_s[qs - 1]", "&rt", "&r", "&sqds"], 0, 12, 7))>;
            temp = e[qs - 1];
            rt = temp * -sqds;
            e[qs - 1] = temp * r;
            kase = (qs - 1) << 1;
            b_iy = (q - 1) << 1;
            temp = r * U[kase] + sqds * U[b_iy];
            U[b_iy] = r * U[b_iy] - sqds * U[kase];
            U[kase] = temp;
            temp = U[b_iy + 1];
            emm1 = U[kase + 1];
            U[b_iy + 1] = temp * r - emm1 * sqds;
            U[kase + 1] = emm1 * r + temp * sqds;
        }
}
        break;
      case 3: {
        real_T emm1;
        real_T shift;
        rt = b_s[m - 1];
        r = fmax(fmax(fmax(fmax(fabs(rt), fabs(b_s[0])), fabs(e[0])), fabs(b_s[q])), fabs(e[q]));
        rt /= r;
        temp = b_s[0] / r;
        emm1 = e[0] / r;
        sqds = b_s[q] / r;
        temp = ((temp + rt) * (temp - rt) + emm1 * emm1) / 2.0;
        emm1 *= rt;
        emm1 *= emm1;
        if ((temp != 0.0) || (emm1 != 0.0)) {
            shift = sqrt(temp * temp + emm1);
            if (temp < 0.0) {
                shift = -shift;
            }
            shift = emm1 / (temp + shift);
        } else {
            shift = 0.0;
        }
        rt = (sqds + rt) * (sqds - rt) + shift;
        r = e[q] / r * sqds;
        for (qs = q + 1; qs < 2; qs++) {
            %<(SLibCGCallSubFcn("cartesian_impedance_contr_xrotg", ["&rt", "&r", "&sqds", "&temp"], 0, 12, 5))>;
            rt = sqds * b_s[0] + temp * e[0];
            e[0] = sqds * e[0] - temp * b_s[0];
            r = temp * b_s[1];
            b_s[1] *= sqds;
            emm1 = sqds * Vf[0] + temp * Vf[2];
            Vf[2] = sqds * Vf[2] - temp * Vf[0];
            Vf[0] = emm1;
            emm1 = sqds * Vf[1] + temp * Vf[3];
            Vf[3] = sqds * Vf[3] - temp * Vf[1];
            Vf[1] = emm1;
            b_s[0] = rt;
            %<(SLibCGCallSubFcn("cartesian_impedance_contr_xrotg", ["&b_s[0]", "&r", "&sqds", "&temp"], 0, 12, 6))>;
            rt = sqds * e[0] + temp * b_s[1];
            b_s[1] = -temp * e[0] + sqds * b_s[1];
            r = temp * e[1];
            e[1] *= sqds;
            emm1 = sqds * U[0] + temp * U[2];
            U[2] = sqds * U[2] - temp * U[0];
            U[0] = emm1;
            emm1 = sqds * U[1] + temp * U[3];
            U[3] = sqds * U[3] - temp * U[1];
            U[1] = emm1;
        }
        e[0] = rt;
        iter++;
}
        break;
      default:
        if (b_s[q] < 0.0) {
            b_s[q] = -b_s[q];
            iter = (q << 1) + 1;
            for (qs = iter; qs <= iter + 1; qs++) {
                Vf[qs - 1] = -Vf[qs - 1];
            }
        }
        while ((q + 1 < 2) && (b_s[0] < b_s[1])) {
            rt = b_s[0];
            b_s[0] = b_s[1];
            b_s[1] = rt;
            %<(SLibCGCallSubFcn("cartesian_impedance_contr_xswap", ["Vf"], 0, 12, 9))>;
            %<(SLibCGCallSubFcn("cartesian_impedance_contr_xswap", ["U"], 0, 12, 10))>;
            q = 1;
        }
        iter = 0;
        m--;
        break;
    }
}
s[0] = b_s[0];
V[0] = Vf[0];
V[1] = Vf[1];
s[1] = b_s[1];
V[2] = Vf[2];
V[3] = Vf[3];
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void cartesian_impedance_cont_svd_bw(\
%assign comma = ""
%<comma>const real_T A[4]\
%assign comma = ", "
%<comma>real_T U[4]\
%assign comma = ", "
%<comma>real_T s[2]\
%assign comma = ", "
%<comma>real_T V[4]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 12, fcnProtoType)>
%return fcnBuff
%endfunction

%function cartesian_impedance_contro_pinv_Fcn13(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T U[4];
real_T V[4];
real_T s[2];
int32_T r;
boolean_T p;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,13,0,0)
%<SLibCG_AccessArg(0 ,13, 0)>
%endif

p = true;
X[0] = 0.0;
if (rtIsInf(A[0]) || rtIsNaN(A[0])) {
    p = false;
}
X[1] = 0.0;
if (p && ((!rtIsInf(A[1])) && (!rtIsNaN(A[1])))) {
} else {
    p = false;
}
X[2] = 0.0;
if (p && ((!rtIsInf(A[2])) && (!rtIsNaN(A[2])))) {
} else {
    p = false;
}
X[3] = 0.0;
if (p && ((!rtIsInf(A[3])) && (!rtIsNaN(A[3])))) {
} else {
    p = false;
}
if (!p) {
    X[0] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    X[1] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    X[2] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    X[3] = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
} else {
    real_T absx;
    int32_T vcol;
    %<(SLibCGCallSubFcn("cartesian_impedance_cont_svd_bw", ["A", "U", "s", "V"], 0, 13, 0))>;
    absx = fabs(s[0]);
    if (rtIsInf(absx) || rtIsNaN(absx)) {
        absx = %<LibGetMathConstant(LibRealNonFinite("nan"), FcnGetDataTypeIdFromName("double"))>;
    } else if (absx < 4.4501477170144028E-308) {
        absx = 4.94065645841247E-324;
    } else {
        frexp(absx, &r);
        absx = ldexp(1.0, r - 53);
    }
    absx *= 2.0;
    r = -1;
    vcol = 0;
    while ((vcol < 2) && (s[vcol] > absx)) {
        r++;
        vcol++;
    }
    if (r + 1 > 0) {
        int32_T ar;
        vcol = 1;
        for ( int32_T j = 0; j <= r; j++) {
            absx = 1.0 / s[j];
            for (ar = vcol; ar <= vcol + 1; ar++) {
                V[ar - 1] *= absx;
            }
            vcol += 2;
        }
        for (vcol = 0; vcol <= 2; vcol += 2) {
            for ( int32_T j = vcol + 1; j <= vcol + 2; j++) {
                X[j - 1] = 0.0;
            }
        }
        vcol = 0;
        for ( int32_T j = 0; j <= 2; j += 2) {
            int32_T b;
            ar = -1;
            vcol++;
            b = (r << 1) + vcol;
            for ( int32_T ib = vcol; ib <= b; ib += 2) {
                for ( int32_T b_ic = j + 1; b_ic <= j + 2; b_ic++) {
                    X[b_ic - 1] += V[(ar + b_ic) - j] * U[ib - 1];
                }
                ar += 2;
            }
        }
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void cartesian_impedance_contro_pinv(\
%assign comma = ""
%<comma>const real_T A[4]\
%assign comma = ", "
%<comma>real_T X[4]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 13, fcnProtoType)>
%return fcnBuff
%endfunction


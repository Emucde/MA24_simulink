%implements s9_b0_hij8o_Outputs "C"

%function Outputs(block, system) Output
%assign cfgTxt = ""
%openfile cfgTxt
%assign localVarDecl = ""
%openfile localVarDecl

static const real_T b_param_traj_data_p_d[157515] = %<(TLC_STR_CTX(1))>;
static const real_T b_param_traj_data_p_d_p[157515] = %<(TLC_STR_CTX(2))>;
static const real_T b_param_traj_data_p_d_pp[157515] = %<(TLC_STR_CTX(3))>;
real_T a[49];
real_T d[49];
real_T d_0[49];
real_T K_d[25];
real_T K_d_0[25];
real_T y[25];
real_T a_0[7];
real_T d_1[7];
real_T rtb_ManualSwitch1[7];
real_T tmp_1[6];
real_T K_d_1[5];
real_T tmp_2[5];
real_T y_0[5];
real_T J_pinv[4];
real_T J_pinv_T[4];
real_T J_red[4];
real_T J_tilde[4];
real_T J_tilde_0[4];
real_T tmp_0[4];
real_T v[4];
real_T J_pinv_T_0[2];
real_T tmp[2];
real_T J_scale_idx_0;
real_T J_tilde_tmp;
real_T bkj;
real_T reshapes_f1_idx_1;
real_T rtb_Clock;
int32_T i;
int32_T idx;
int32_T ii;
int8_T b_j_data[4];
int8_T c_data[2];
boolean_T x[4];
static const real_T c_a[4] = %<(TLC_STR_CTX(4))>;
static const int8_T b_1[5] = %<(TLC_STR_CTX(5))>;
int32_T B_size[2];
int32_T J_new_size[2];
%closefile localVarDecl
%assign tlcOutputsFcnOfS9B0 = OpaqueTLCBlockFcn("Outputs", 9, 0, 0, 16, 0)
%assign tlcOutputsFcnOfS9B1 = OpaqueTLCBlockFcn("Outputs", 9, 1, 0, 16, 1)
%assign tlcOutputsFcnOfS9B4 = OpaqueTLCBlockFcn("Outputs", 9, 4, 0, 16, 2)
%assign tlcOutputsFcnOfS9B6 = OpaqueTLCBlockFcn("Outputs", 9, 6, 0, 16, 3)
%assign tlcOutputsFcnOfS9B7 = OpaqueTLCBlockFcn("Outputs", 9, 7, 0, 16, 4)
%assign tlcOutputsFcnOfS9B21 = OpaqueTLCBlockFcn("Outputs", 9, 21, 0, 16, 5)
%assign tlcOutputsFcnOfS9B22 = OpaqueTLCBlockFcn("Outputs", 9, 22, 0, 16, 6)
%assign tlcOutputsFcnOfS9B23 = OpaqueTLCBlockFcn("Outputs", 9, 23, 0, 16, 7)
%assign tlcOutputsFcnOfS9B24 = OpaqueTLCBlockFcn("Outputs", 9, 24, 0, 16, 8)
%assign tlcOutputsFcnOfS9B25 = OpaqueTLCBlockFcn("Outputs", 9, 25, 0, 16, 9)
%assign tlcOutputsFcnOfS9B26 = OpaqueTLCBlockFcn("Outputs", 9, 26, 0, 16, 10)
%assign tlcOutputsFcnOfS9B27 = OpaqueTLCBlockFcn("Outputs", 9, 27, 0, 16, 11)
%assign tlcOutputsFcnOfS9B29 = OpaqueTLCBlockFcn("Outputs", 9, 29, 0, 16, 12)
%assign tlcOutputsFcnOfS9B30 = OpaqueTLCBlockFcn("Outputs", 9, 30, 0, 16, 13)
%assign tlcOutputsFcnOfS9B31 = OpaqueTLCBlockFcn("Outputs", 9, 31, 0, 16, 14)
%assign tlcOutputsFcnOfS9B32 = OpaqueTLCBlockFcn("Outputs", 9, 32, 0, 16, 15)
%assign tlcOutputsFcnOfS9B33 = OpaqueTLCBlockFcn("Outputs", 9, 33, 0, 16, 16)
%assign tlcOutputsFcnOfS9B34 = OpaqueTLCBlockFcn("Outputs", 9, 34, 0, 16, 17)
%<SLibGenerateExtModeOutput(system)>
%if !WHITE_SPACE(tlcOutputsFcnOfS9B0)
/* {S!d1474}S-Function (get_robot_state): '<S6>/Get Robot State2' */
%<tlcOutputsFcnOfS9B0>\
%endif
%if !WHITE_SPACE(tlcOutputsFcnOfS9B1)
/* {S!d1476}S-Function (shm_reader_sfun): '<Root>/S-Function3' */
%<tlcOutputsFcnOfS9B1>\
%endif
/* {S!d1478}Clock: '<S6>/Clock' */
rtb_Clock = %<(SLibCG_SE(LibGetT()))>;
for (i = 0; i < 7; i++) {
    /* {S!d1484}Switch: '<S6>/Switch' */
    if (rtb_Clock > cartesian_impedance_control_P.Switch_Threshold) {
        /* {S!d1480}Switch: '<S6>/Switch' */
        cartesian_impedance_control_B.Switch[i] = cartesian_impedance_control_B.GetRobotState2_o1[i];
    } else {
        /* {S!d1482}Switch: '<S6>/Switch' incorporates:
 *  Constant: '<S6>/Constant'
 */
        cartesian_impedance_control_B.Switch[i] = cartesian_impedance_control_P.q_init[i];
    }
    /* {E!d1484}End of Switch: '<S6>/Switch' */
}
/* {S!d1486}MATLAB Function: '<Root>/MATLAB Function3' */
if (cartesian_impedance_control_B.SFunction3_o2 == 1.0) {
    memcpy(&cartesian_impedance_control_B.y[0], &cartesian_impedance_control_B.SFunction3_o1[0], 14U * sizeof(real_T));
    cartesian_impedance_control_B.simulink_valid_flag = 1.0;
} else {
    memset(&cartesian_impedance_control_B.y[0], 0, 14U * sizeof(real_T));
    cartesian_impedance_control_B.simulink_valid_flag = 0.0;
}
/* {E!d1486}End of MATLAB Function: '<Root>/MATLAB Function3' */
for (i = 0; i < 7; i++) {
    /* {S!d1492}ManualSwitch: '<Root>/Manual Switch' */
    if (cartesian_impedance_control_P.ManualSwitch_CurrentSetting == 1) {
        /* {S!d1488}ManualSwitch: '<Root>/Manual Switch' */
        cartesian_impedance_control_B.ManualSwitch[i] = cartesian_impedance_control_B.Switch[i];
        cartesian_impedance_control_B.ManualSwitch[i + 7] = cartesian_impedance_control_B.GetRobotState2_o2[i];
    } else {
        /* {S!d1490}ManualSwitch: '<Root>/Manual Switch' */
        cartesian_impedance_control_B.ManualSwitch[i] = cartesian_impedance_control_B.y[i];
        cartesian_impedance_control_B.ManualSwitch[i + 7] = cartesian_impedance_control_B.y[i + 7];
    }
    /* {E!d1492}End of ManualSwitch: '<Root>/Manual Switch' */
}
%if !WHITE_SPACE(tlcOutputsFcnOfS9B4)
/* {S!d1494}S-Function (shm_writer_sfun): '<Root>/S-Function4' */
%<tlcOutputsFcnOfS9B4>\
%endif
%if !WHITE_SPACE(tlcOutputsFcnOfS9B6)
/* {S!d1496}S-Function (s_function_opti_sys_fun_qpp_aba): '<Root>/S-Function1' incorporates:
 *  Constant: '<Root>/tau_in'
 */
%<tlcOutputsFcnOfS9B6>\
%endif
%if !WHITE_SPACE(tlcOutputsFcnOfS9B7)
/* {S!d1498}S-Function (s_function_opti_robot_model_bus_fun): '<Root>/S-Function2' */
%<tlcOutputsFcnOfS9B7>\
%endif
/* {S!d1500}MATLAB Function: '<Root>/get data' incorporates:
 *  Constant: '<Root>/Constant4'
 *  Constant: '<Root>/Constant5'
 */
i = (static_cast<int32_T>(cartesian_impedance_control_P.Constant5_Value) - 1) * 31503;
idx = (static_cast<int32_T>((cartesian_impedance_control_DW.cnt - 1.0) + cartesian_impedance_control_P.Constant4_Value) - 1) * 3 + i;
cartesian_impedance_control_B.p_d[0] = b_param_traj_data_p_d[idx];
cartesian_impedance_control_B.p_d[1] = b_param_traj_data_p_d[idx + 1];
cartesian_impedance_control_B.p_d[2] = b_param_traj_data_p_d[idx + 2];
/* {S!d1502}MATLAB Function: '<Root>/PD+ controller reduced' incorporates:
 *  MATLAB Function: '<Root>/Robot model bus'
 *  S-Function (s_function_opti_robot_model_bus_fun): '<Root>/S-Function2'
 */
J_red[0] = cartesian_impedance_control_B.J[6];
J_red[1] = cartesian_impedance_control_B.J[8];
/* {S!d1504}MATLAB Function: '<Root>/get data' incorporates:
 *  MATLAB Function: '<Root>/PD+ controller reduced'
 */
i += (static_cast<int32_T>(cartesian_impedance_control_DW.cnt) - 1) * 3;
/* {S!d1506}MATLAB Function: '<Root>/PD+ controller reduced' incorporates:
 *  Constant: '<Root>/cartesian damping'
 *  Constant: '<Root>/cartesian stiffness'
 *  MATLAB Function: '<Root>/Robot model bus'
 *  MATLAB Function: '<Root>/get data'
 *  S-Function (s_function_opti_robot_model_bus_fun): '<Root>/S-Function2'
 */
rtb_Clock = cartesian_impedance_control_B.H[12] - b_param_traj_data_p_d[i];
J_red[2] = cartesian_impedance_control_B.J[18];
J_red[3] = cartesian_impedance_control_B.J[20];
reshapes_f1_idx_1 = cartesian_impedance_control_B.H[14] - b_param_traj_data_p_d[i + 2];
if (cartesian_impedance_control_P.ctrl_param.regularization.mode == 0.0) {
    %<(SLibCGCallSubFcn("cartesian_impedance_co_mldivide", ["J_red", "c_a", "J_pinv"], 0, 16, 1))>;
} else if (cartesian_impedance_control_P.ctrl_param.regularization.mode == 1.0) {
    for (idx = 0; idx < 2; idx++) {
        int32_T jj;
        ii = idx << 1;
        jj = (ii + 1) * 6;
        bkj = cartesian_impedance_control_B.J[jj + 2];
        J_tilde_tmp = cartesian_impedance_control_B.J[jj];
        J_tilde_0[idx] = (bkj * cartesian_impedance_control_B.J[8] + J_tilde_tmp * cartesian_impedance_control_B.J[6]) + cartesian_impedance_control_P.ctrl_param.regularization.k * c_a[idx];
        v[ii] = cartesian_impedance_control_B.J[ii + 6];
        J_tilde_0[idx + 2] = (bkj * cartesian_impedance_control_B.J[20] + J_tilde_tmp * cartesian_impedance_control_B.J[18]) + c_a[idx + 2] * cartesian_impedance_control_P.ctrl_param.regularization.k;
        v[ii + 1] = cartesian_impedance_control_B.J[ii + 18];
    }
    %<(SLibCGCallSubFcn("cartesian_impedance_co_mldivide", ["J_tilde_0", "v", "J_pinv"], 0, 16, 2))>;
} else if (cartesian_impedance_control_P.ctrl_param.regularization.mode == 2.0) {
    J_scale_idx_0 = (0.5 * rtb_Clock * cartesian_impedance_control_P.ctrl_param.regularization.W_E[0] + 0.5 * reshapes_f1_idx_1 * cartesian_impedance_control_P.ctrl_param.regularization.W_E[2]) * rtb_Clock + (0.5 * rtb_Clock * cartesian_impedance_control_P.ctrl_param.regularization.W_E[12] + 0.5 * reshapes_f1_idx_1 * cartesian_impedance_control_P.ctrl_param.regularization.W_E[14]) * reshapes_f1_idx_1;
    J_tilde[0] = sqrt(cartesian_impedance_control_P.ctrl_param.regularization.W_E[0]);
    J_tilde[1] = sqrt(cartesian_impedance_control_P.ctrl_param.regularization.W_E[2]);
    J_tilde[2] = sqrt(cartesian_impedance_control_P.ctrl_param.regularization.W_E[12]);
    J_tilde[3] = sqrt(cartesian_impedance_control_P.ctrl_param.regularization.W_E[14]);
    for (idx = 0; idx < 2; idx++) {
        J_tilde_0[idx] = 0.0;
        J_tilde_0[idx] += J_tilde[idx] * cartesian_impedance_control_B.J[6];
        bkj = J_tilde[idx + 2];
        J_tilde_0[idx] += bkj * cartesian_impedance_control_B.J[8];
        J_tilde_0[idx + 2] = 0.0;
        J_tilde_0[idx + 2] += J_tilde[idx] * cartesian_impedance_control_B.J[18];
        J_tilde_0[idx + 2] += bkj * cartesian_impedance_control_B.J[20];
    }
    %<(SLibCGCallSubFcn("cartesian_impedance_control_svd", ["J_tilde_0", "J_pinv", "v", "J_pinv_T"], 0, 16, 10))>;
    J_tilde[1] = 0.0;
    J_tilde[2] = 0.0;
    J_tilde[0] = v[0];
    J_tilde[3] = v[3];
    for (idx = 0; idx < 2; idx++) {
        ii = idx << 1;
        J_tilde_0[ii] = 0.0;
        bkj = J_tilde[ii];
        J_tilde_0[ii] += bkj * J_tilde[0];
        J_tilde_tmp = J_tilde[ii + 1];
        J_tilde_0[ii] += J_tilde_tmp * 0.0;
        J_tilde_0[ii + 1] = 0.0;
        J_tilde_0[ii + 1] += bkj * 0.0;
        J_tilde_0[ii + 1] += J_tilde_tmp * J_tilde[3];
    }
    for (idx = 0; idx < 2; idx++) {
        v[idx] = 0.0;
        v[idx] += J_pinv_T[idx] * J_tilde_0[0];
        bkj = J_pinv_T[idx + 2];
        v[idx] += bkj * J_tilde_0[1];
        v[idx + 2] = 0.0;
        v[idx + 2] += J_pinv_T[idx] * J_tilde_0[2];
        v[idx + 2] += bkj * J_tilde_0[3];
        J_tilde[idx] = 0.0;
        J_tilde[idx] += v[idx] * J_pinv_T[0];
        J_tilde_tmp = v[idx + 2];
        J_tilde[idx] += J_tilde_tmp * J_pinv_T[2];
        J_tilde[idx + 2] = 0.0;
        J_tilde[idx + 2] += v[idx] * J_pinv_T[1];
        J_tilde[idx + 2] += J_tilde_tmp * J_pinv_T[3];
    }
    J_pinv_T[0] = (J_scale_idx_0 + cartesian_impedance_control_P.ctrl_param.regularization.W_bar_N[1]) + J_tilde[0];
    J_tilde_0[0] = cartesian_impedance_control_B.J[6];
    J_pinv_T[1] = (0.0 * J_scale_idx_0 + cartesian_impedance_control_P.ctrl_param.regularization.W_bar_N[3]) + J_tilde[1];
    J_tilde_0[1] = cartesian_impedance_control_B.J[18];
    J_pinv_T[2] = (0.0 * J_scale_idx_0 + cartesian_impedance_control_P.ctrl_param.regularization.W_bar_N[1]) + J_tilde[2];
    J_tilde_0[2] = cartesian_impedance_control_B.J[8];
    J_pinv_T[3] = (J_scale_idx_0 + cartesian_impedance_control_P.ctrl_param.regularization.W_bar_N[3]) + J_tilde[3];
    J_tilde_0[3] = cartesian_impedance_control_B.J[20];
    %<(SLibCGCallSubFcn("cartesian_impedance_co_mldivide", ["J_pinv_T", "J_tilde_0", "J_pinv"], 0, 16, 3))>;
} else if (cartesian_impedance_control_P.ctrl_param.regularization.mode == 3.0) {
    %<(SLibCGCallSubFcn("cartesian_impedance_control_svd", ["J_red", "J_tilde", "v", "J_pinv_T"], 0, 16, 9))>;
    J_scale_idx_0 = fmax(v[0], cartesian_impedance_control_P.ctrl_param.regularization.eps);
    J_pinv[3] = fmax(v[3], cartesian_impedance_control_P.ctrl_param.regularization.eps);
    for (idx = 0; idx < 2; idx++) {
        J_tilde_0[idx] = 0.0;
        J_tilde_0[idx] += J_tilde[idx] * J_scale_idx_0;
        J_tilde_0[idx] += J_tilde[idx + 2] * 0.0;
        J_tilde_0[idx + 2] = 0.0;
        J_tilde_0[idx + 2] += J_tilde[idx] * 0.0;
        J_tilde_0[idx + 2] += J_tilde[idx + 2] * J_pinv[3];
        v[idx] = 0.0;
        v[idx] += J_tilde_0[idx] * J_pinv_T[0];
        v[idx] += J_tilde_0[idx + 2] * J_pinv_T[2];
        v[idx + 2] = 0.0;
        v[idx + 2] += J_tilde_0[idx] * J_pinv_T[1];
        v[idx + 2] += J_tilde_0[idx + 2] * J_pinv_T[3];
    }
    %<(SLibCGCallSubFcn("cartesian_impedance_contro_pinv", ["v", "J_pinv"], 0, 16, 4))>;
} else if (cartesian_impedance_control_P.ctrl_param.regularization.mode == 4.0) {
    if (%<(SLibCGCallSubFcn("cartesian_impedance__local_rank", ["J_red"], 0, 16, 0))> < 2) {
        int32_T jj;
        boolean_T exitg1;
        %<(SLibCGCallSubFcn("cartesian_impedance_con_vecnorm", ["J_red", "tmp"], 0, 16, 12))>;
        J_tilde[0] = cartesian_impedance_control_B.J[6] / tmp[0];
        J_tilde[1] = cartesian_impedance_control_B.J[8] / tmp[0];
        J_tilde[2] = cartesian_impedance_control_B.J[18] / tmp[1];
        J_tilde[3] = cartesian_impedance_control_B.J[20] / tmp[1];
        for (idx = 0; idx < 2; idx++) {
            J_pinv_T[idx] = 0.0;
            ii = idx << 1;
            bkj = J_tilde[ii];
            J_pinv_T[idx] += bkj * J_tilde[0];
            J_tilde_tmp = J_tilde[ii + 1];
            J_pinv_T[idx] += J_tilde_tmp * J_tilde[1];
            J_pinv_T[idx + 2] = 0.0;
            J_pinv_T[idx + 2] += bkj * J_tilde[2];
            J_pinv_T[idx + 2] += J_tilde_tmp * J_tilde[3];
        }
        J_pinv_T[0]--;
        x[0] = (fabs(J_pinv_T[0]) > cartesian_impedance_control_P.ctrl_param.regularization.eps_collinear);
        x[1] = (fabs(J_pinv_T[1]) > cartesian_impedance_control_P.ctrl_param.regularization.eps_collinear);
        x[2] = (cartesian_impedance_control_P.ctrl_param.regularization.eps_collinear < 0.0);
        J_pinv_T[3]--;
        x[3] = (fabs(J_pinv_T[3]) > cartesian_impedance_control_P.ctrl_param.regularization.eps_collinear);
        idx = -1;
        ii = 1;
        jj = 1;
        exitg1 = false;
        while ((!exitg1) && (jj <= 2)) {
            boolean_T guard1;
            guard1 = false;
            if (x[(((jj - 1) << 1) + ii) - 1]) {
                idx++;
                b_j_data[idx] = static_cast<int8_T>(jj);
                if (idx + 1 >= 4) {
                    exitg1 = true;
                } else {
                    guard1 = true;
                }
            } else {
                guard1 = true;
            }
            if (guard1) {
                ii++;
                if (ii > 2) {
                    ii = 1;
                    jj++;
                }
            }
        }
        if (idx + 1 < 1) {
            idx = -1;
        }
        ii = idx + 1;
        for (idx = 0; idx < ii; idx++) {
            jj = (b_j_data[idx] - 1) << 1;
            J_red[jj] = 0.0;
            J_red[jj + 1] = 0.0;
        }
        %<(SLibCGCallSubFcn("cartesian_impedance_contro_pinv", ["J_red", "J_pinv"], 0, 16, 5))>;
    } else {
        %<(SLibCGCallSubFcn("cartesian_impedance_co_mldivide", ["J_red", "c_a", "J_pinv"], 0, 16, 6))>;
    }
} else {
    real_T J_scale_idx_1;
    int32_T c_size_idx_0;
    int32_T jj;
    boolean_T b;
    boolean_T b_idx_0;
    %<(SLibCGCallSubFcn("cartesian_impedance_con_vecnorm", ["J_red", "tmp"], 0, 16, 11))>;
    J_scale_idx_0 = 1.0 / tmp[0];
    J_tilde[0] = cartesian_impedance_control_B.J[6] * J_scale_idx_0;
    J_tilde[1] = cartesian_impedance_control_B.J[8] * J_scale_idx_0;
    J_scale_idx_1 = 1.0 / tmp[1];
    J_tilde[2] = cartesian_impedance_control_B.J[18] * J_scale_idx_1;
    J_tilde[3] = cartesian_impedance_control_B.J[20] * J_scale_idx_1;
    for (idx = 0; idx < 2; idx++) {
        J_tilde_0[idx] = 0.0;
        ii = idx << 1;
        bkj = J_tilde[ii];
        J_tilde_0[idx] += bkj * J_tilde[0];
        J_tilde_tmp = J_tilde[ii + 1];
        J_tilde_0[idx] += J_tilde_tmp * J_tilde[1];
        J_tilde_0[idx + 2] = 0.0;
        J_tilde_0[idx + 2] += bkj * J_tilde[2];
        J_tilde_0[idx + 2] += J_tilde_tmp * J_tilde[3];
    }
    %<(SLibCGCallSubFcn("cartesian_impedance_control_svd", ["J_tilde_0", "J_pinv", "v", "J_pinv_T"], 0, 16, 8))>;
    idx = 0;
    b = (v[0] > cartesian_impedance_control_P.ctrl_param.regularization.lambda_min);
    if (b) {
        idx = 1;
    }
    b_idx_0 = b;
    b = (v[3] > cartesian_impedance_control_P.ctrl_param.regularization.lambda_min);
    if (b) {
        idx++;
    }
    c_size_idx_0 = idx;
    idx = 0;
    if (b_idx_0) {
        c_data[0] = 1;
        idx = 1;
    }
    if (b) {
        c_data[idx] = 2;
    }
    for (idx = 0; idx < c_size_idx_0; idx++) {
        jj = (c_data[idx] - 1) << 1;
        J_tilde[idx << 1] = J_pinv_T[jj] * J_scale_idx_0;
        J_tilde[1 + (idx << 1)] = J_pinv_T[jj + 1] * J_scale_idx_1;
    }
    J_new_size[0] = 2;
    J_new_size[1] = c_size_idx_0;
    for (idx = 0; idx < c_size_idx_0; idx++) {
        jj = idx << 1;
        J_pinv[jj] = J_tilde[jj + 1] * cartesian_impedance_control_B.J[18] + J_tilde[jj] * cartesian_impedance_control_B.J[6];
        J_pinv[jj + 1] = J_tilde[jj + 1] * cartesian_impedance_control_B.J[20] + J_tilde[jj] * cartesian_impedance_control_B.J[8];
    }
    %<(SLibCGCallSubFcn("cartesian_impedance__mldivide_p", ["J_pinv", "J_new_size", "J_pinv_T", "B_size"], 0, 16, 7))>;
    for (idx = 0; idx < 2; idx++) {
        int32_T b_boffset;
        jj = idx << 1;
        b_boffset = idx * B_size[0];
        J_pinv[jj] = 0.0;
        J_pinv[jj + 1] = 0.0;
        for (ii = 0; ii < c_size_idx_0; ii++) {
            int32_T aoffset;
            aoffset = ii << 1;
            bkj = J_pinv_T[b_boffset + ii];
            J_pinv[jj] += J_tilde[aoffset] * bkj;
            J_pinv[jj + 1] += J_tilde[aoffset + 1] * bkj;
        }
    }
}
J_pinv_T[0] = J_pinv[0];
J_pinv_T[1] = J_pinv[2];
J_pinv_T[2] = J_pinv[1];
J_pinv_T[3] = J_pinv[3];
for (idx = 0; idx < 2; idx++) {
    v[idx] = 0.0;
    v[idx] += J_pinv_T[idx] * cartesian_impedance_control_B.M[8];
    bkj = J_pinv_T[idx + 2];
    v[idx] += bkj * cartesian_impedance_control_B.M[10];
    v[idx + 2] = 0.0;
    v[idx + 2] += J_pinv_T[idx] * cartesian_impedance_control_B.M[22];
    v[idx + 2] += bkj * cartesian_impedance_control_B.M[24];
    J_tilde[idx] = 0.0;
    J_tilde[idx] += v[idx] * J_pinv[0];
    J_tilde[idx] += v[idx + 2] * J_pinv[1];
    J_tilde[idx + 2] = 0.0;
    J_tilde[idx + 2] += v[idx] * J_pinv[2];
    J_tilde[idx + 2] += v[idx + 2] * J_pinv[3];
}
for (idx = 0; idx < 2; idx++) {
    ii = idx << 1;
    J_tilde_0[ii] = (J_tilde[ii] + J_tilde[idx]) * 0.5;
    v[idx] = 0.0;
    bkj = cartesian_impedance_control_B.M[ii + 8];
    v[idx] += bkj * J_pinv[0];
    J_tilde_tmp = cartesian_impedance_control_B.M[ii + 22];
    v[idx] += J_tilde_tmp * J_pinv[1];
    J_tilde_0[ii + 1] = (J_tilde[ii + 1] + J_tilde[idx + 2]) * 0.5;
    v[idx + 2] = 0.0;
    v[idx + 2] += bkj * J_pinv[2];
    v[idx + 2] += J_tilde_tmp * J_pinv[3];
    tmp_0[idx] = cartesian_impedance_control_B.g[ii + 8] - (v[idx + 2] * cartesian_impedance_control_B.J_p[8] + v[idx] * cartesian_impedance_control_B.J_p[6]);
    tmp_0[idx + 2] = cartesian_impedance_control_B.g[ii + 22] - (v[idx + 2] * cartesian_impedance_control_B.J_p[20] + v[idx] * cartesian_impedance_control_B.J_p[18]);
}
for (idx = 0; idx < 2; idx++) {
    v[idx] = 0.0;
    v[idx] += J_pinv_T[idx] * tmp_0[0];
    bkj = J_pinv_T[idx + 2];
    v[idx] += bkj * tmp_0[1];
    v[idx + 2] = 0.0;
    v[idx + 2] += J_pinv_T[idx] * tmp_0[2];
    v[idx + 2] += bkj * tmp_0[3];
    J_tilde[idx] = 0.0;
    J_tilde[idx] += v[idx] * J_pinv[0];
    J_tilde[idx] += v[idx + 2] * J_pinv[1];
    bkj = b_param_traj_data_p_d_p[i] * J_tilde[idx];
    J_tilde[idx + 2] = 0.0;
    J_tilde[idx + 2] += v[idx] * J_pinv[2];
    J_tilde[idx + 2] += v[idx + 2] * J_pinv[3];
    tmp[idx] = b_param_traj_data_p_d_pp[i + 2] * J_tilde_0[idx + 2] + b_param_traj_data_p_d_pp[i] * J_tilde_0[idx];
    J_pinv_T_0[idx] = b_param_traj_data_p_d_p[i + 2] * J_tilde[idx + 2] + bkj;
}
for (idx = 0; idx < 6; idx++) {
    tmp_1[idx] = 0.0;
    for (ii = 0; ii < 7; ii++) {
        tmp_1[idx] += cartesian_impedance_control_B.J[6 * ii + idx] * cartesian_impedance_control_B.GetRobotState2_o2[ii];
    }
}
bkj = tmp_1[0] - b_param_traj_data_p_d_p[i];
J_tilde_tmp = tmp_1[2] - b_param_traj_data_p_d_p[i + 2];
J_scale_idx_0 = ((tmp[0] + J_pinv_T_0[0]) - (cartesian_impedance_control_P.cartesiandamping_Value[0] * bkj + cartesian_impedance_control_P.cartesiandamping_Value[12] * J_tilde_tmp)) - (cartesian_impedance_control_P.cartesianstiffness_Value[0] * rtb_Clock + cartesian_impedance_control_P.cartesianstiffness_Value[12] * reshapes_f1_idx_1);
J_tilde_tmp = ((tmp[1] + J_pinv_T_0[1]) - (cartesian_impedance_control_P.cartesiandamping_Value[2] * bkj + cartesian_impedance_control_P.cartesiandamping_Value[14] * J_tilde_tmp)) - (cartesian_impedance_control_P.cartesianstiffness_Value[2] * rtb_Clock + cartesian_impedance_control_P.cartesianstiffness_Value[14] * reshapes_f1_idx_1);
cartesian_impedance_control_B.tau_h[0] = 0.0;
cartesian_impedance_control_B.tau_h[0] += J_red[0] * J_scale_idx_0;
cartesian_impedance_control_B.tau_h[0] += J_red[1] * J_tilde_tmp;
cartesian_impedance_control_B.tau_h[1] = 0.0;
cartesian_impedance_control_B.tau_h[1] += J_red[2] * J_scale_idx_0;
cartesian_impedance_control_B.tau_h[1] += J_red[3] * J_tilde_tmp;
/* {S!d1508}ManualSwitch: '<Root>/Manual Switch1' incorporates:
 *  Constant: '<Root>/Constant3'
 *  Constant: '<Root>/Constant8'
 */
for (i = 0; i < 7; i++) {
    if (cartesian_impedance_control_P.ManualSwitch1_CurrentSetting == 1) {
        rtb_ManualSwitch1[i] = cartesian_impedance_control_P.Constant8_Value[i];
    } else {
        rtb_ManualSwitch1[i] = cartesian_impedance_control_P.Constant3_Value[i];
    }
}
/* {E!d1508}End of ManualSwitch: '<Root>/Manual Switch1' */

/* {S!d1510}MATLAB Function: '<Root>/joint space control fixed q3' incorporates:
 *  Constant: '<Root>/Constant9'
 *  Constant: '<Root>/q_d_3'
 *  MATLAB Function: '<Root>/Robot model bus'
 */
memset(&y[0], 0, 25U * sizeof(real_T));
for (i = 0; i < 5; i++) {
    y[i + 5 * i] = cartesian_impedance_control_P.Constant9_Value[b_1[i]];
}
memset(&K_d[0], 0, 25U * sizeof(real_T));
for (i = 0; i < 5; i++) {
    K_d[i + 5 * i] = rtb_ManualSwitch1[b_1[i]];
}
for (i = 0; i < 7; i++) {
    cartesian_impedance_control_B.tau[i] = 0.0;
}
cartesian_impedance_control_B.tau[1] = cartesian_impedance_control_B.tau_h[0];
cartesian_impedance_control_B.tau[3] = cartesian_impedance_control_B.tau_h[1];
for (idx = 0; idx < 25; idx++) {
    K_d_0[idx] = -K_d[idx];
}
for (idx = 0; idx < 5; idx++) {
    int8_T b_0;
    b_0 = b_1[idx];
    tmp_2[idx] = cartesian_impedance_control_B.Switch[b_0] - cartesian_impedance_control_P.q_d_3_Value[b_0];
}
for (idx = 0; idx < 5; idx++) {
    K_d_1[idx] = 0.0;
    y_0[idx] = 0.0;
    for (ii = 0; ii < 5; ii++) {
        i = 5 * ii + idx;
        K_d_1[idx] += K_d_0[i] * tmp_2[ii];
        y_0[idx] += y[i] * cartesian_impedance_control_B.GetRobotState2_o2[b_1[ii]];
    }
    cartesian_impedance_control_B.tau[b_1[idx]] = K_d_1[idx] - y_0[idx];
}
/* {E!d1510}End of MATLAB Function: '<Root>/joint space control fixed q3' */

/* {S!d1512}MATLAB Function: '<Root>/Joinspace controller' incorporates:
 *  Constant: '<Root>/Constant9'
 *  Constant: '<Root>/q_d_3'
 */
memset(&d[0], 0, 49U * sizeof(real_T));
for (i = 0; i < 7; i++) {
    d[i + 7 * i] = cartesian_impedance_control_P.Constant9_Value[i];
}
memset(&a[0], 0, 49U * sizeof(real_T));
for (i = 0; i < 7; i++) {
    a[i + 7 * i] = rtb_ManualSwitch1[i];
}
for (idx = 0; idx < 49; idx++) {
    d_0[idx] = -d[idx];
}
for (idx = 0; idx < 7; idx++) {
    rtb_ManualSwitch1[idx] = cartesian_impedance_control_B.Switch[idx] - cartesian_impedance_control_P.q_d_3_Value[idx];
    d_1[idx] = 0.0;
    for (ii = 0; ii < 7; ii++) {
        d_1[idx] += d_0[7 * ii + idx] * cartesian_impedance_control_B.GetRobotState2_o2[ii];
    }
}
for (idx = 0; idx < 7; idx++) {
    a_0[idx] = 0.0;
    for (ii = 0; ii < 7; ii++) {
        a_0[idx] += a[7 * ii + idx] * rtb_ManualSwitch1[ii];
    }
    cartesian_impedance_control_B.tau_c[idx] = d_1[idx] - a_0[idx];
}
/* {E!d1512}End of MATLAB Function: '<Root>/Joinspace controller' */
%if !WHITE_SPACE(tlcOutputsFcnOfS9B21)

/* {S!d1514}Scope: '<Root>/Scope5' */
%<tlcOutputsFcnOfS9B21>\
%endif
%if !WHITE_SPACE(tlcOutputsFcnOfS9B22)
/* {S!d1516}ToAsyncQueueBlock generated from: '<Root>/From31' */
%<tlcOutputsFcnOfS9B22>\
%endif
/* {S!d1524}RateLimiter: '<S6>/Rate Limiter' */
bkj = cartesian_impedance_control_P.RateLimiter_RisingLim * cartesian_impedance_cont_period;
J_tilde_tmp = cartesian_impedance_control_P.RateLimiter_FallingLim * cartesian_impedance_cont_period;
for (i = 0; i < 7; i++) {
    cartesian_impedance_control_B.RateLimiter[i] = cartesian_impedance_control_B.tau_c[i] - cartesian_impedance_control_DW.PrevY[i];
    if (cartesian_impedance_control_B.RateLimiter[i] > bkj) {
        /* {S!d1518}RateLimiter: '<S6>/Rate Limiter' */
        cartesian_impedance_control_B.RateLimiter[i] = cartesian_impedance_control_DW.PrevY[i] + bkj;
    } else if (cartesian_impedance_control_B.RateLimiter[i] < J_tilde_tmp) {
        /* {S!d1520}RateLimiter: '<S6>/Rate Limiter' */
        cartesian_impedance_control_B.RateLimiter[i] = cartesian_impedance_control_DW.PrevY[i] + J_tilde_tmp;
    } else {
        /* {S!d1522}RateLimiter: '<S6>/Rate Limiter' */
        cartesian_impedance_control_B.RateLimiter[i] = cartesian_impedance_control_B.tau_c[i];
    }
    cartesian_impedance_control_DW.PrevY[i] = cartesian_impedance_control_B.RateLimiter[i];
}
/* {E!d1524}End of RateLimiter: '<S6>/Rate Limiter' */
%if !WHITE_SPACE(tlcOutputsFcnOfS9B23)

/* {S!d1526}S-Function (apply_control): '<S6>/Apply Control' */
%<tlcOutputsFcnOfS9B23>\
%endif
%if !WHITE_SPACE(tlcOutputsFcnOfS9B24)
/* {S!d1528}ToAsyncQueueBlock generated from: '<Root>/From30' */
%<tlcOutputsFcnOfS9B24>\
%endif
%if !WHITE_SPACE(tlcOutputsFcnOfS9B25)
/* {S!d1530}Scope: '<Root>/Scope' */
%<tlcOutputsFcnOfS9B25>\
%endif
%if !WHITE_SPACE(tlcOutputsFcnOfS9B26)
/* {S!d1532}ToAsyncQueueBlock generated from: '<Root>/Subsystem' */
%<tlcOutputsFcnOfS9B26>\
%endif
%if !WHITE_SPACE(tlcOutputsFcnOfS9B27)
/* {S!d1534}ToAsyncQueueBlock generated from: '<Root>/Subsystem' */
%<tlcOutputsFcnOfS9B27>\
%endif
/* {S!d1536}MATLAB Function: '<Root>/MATLAB Function2' incorporates:
 *  MATLAB Function: '<Root>/Robot model bus'
 *  S-Function (s_function_opti_robot_model_bus_fun): '<Root>/S-Function2'
 */
cartesian_impedance_control_B.p[0] = cartesian_impedance_control_B.H[12];
/* {S!d1538}SignalConversion generated from: '<Root>/Mux2' */
cartesian_impedance_control_B.TmpSignalConversionAtTAQSigLogg[0] = cartesian_impedance_control_B.p[0];
cartesian_impedance_control_B.TmpSignalConversionAtTAQSigLogg[3] = cartesian_impedance_control_B.p_d[0];
/* {S!d1540}MATLAB Function: '<Root>/MATLAB Function2' incorporates:
 *  MATLAB Function: '<Root>/Robot model bus'
 *  S-Function (s_function_opti_robot_model_bus_fun): '<Root>/S-Function2'
 */
cartesian_impedance_control_B.p[1] = cartesian_impedance_control_B.H[13];
/* {S!d1542}SignalConversion generated from: '<Root>/Mux2' */
cartesian_impedance_control_B.TmpSignalConversionAtTAQSigLogg[1] = cartesian_impedance_control_B.p[1];
cartesian_impedance_control_B.TmpSignalConversionAtTAQSigLogg[4] = cartesian_impedance_control_B.p_d[1];
/* {S!d1544}MATLAB Function: '<Root>/MATLAB Function2' incorporates:
 *  MATLAB Function: '<Root>/Robot model bus'
 *  S-Function (s_function_opti_robot_model_bus_fun): '<Root>/S-Function2'
 */
cartesian_impedance_control_B.p[2] = cartesian_impedance_control_B.H[14];
/* {S!d1546}SignalConversion generated from: '<Root>/Mux2' */
cartesian_impedance_control_B.TmpSignalConversionAtTAQSigLogg[2] = cartesian_impedance_control_B.p[2];
cartesian_impedance_control_B.TmpSignalConversionAtTAQSigLogg[5] = cartesian_impedance_control_B.p_d[2];
%if !WHITE_SPACE(tlcOutputsFcnOfS9B29)
/* {S!d1548}ToAsyncQueueBlock generated from: '<Root>/Mux2' */
%<tlcOutputsFcnOfS9B29>\
%endif
%if !WHITE_SPACE(tlcOutputsFcnOfS9B30)
/* {S!d1550}Scope: '<Root>/err scope all' */
%<tlcOutputsFcnOfS9B30>\
%endif
%if !WHITE_SPACE(tlcOutputsFcnOfS9B31)
/* {S!d1552}ToAsyncQueueBlock generated from: '<Root>/Subsystem' */
%<tlcOutputsFcnOfS9B31>\
%endif
%if !WHITE_SPACE(tlcOutputsFcnOfS9B32)
/* {S!d1554}ToAsyncQueueBlock generated from: '<Root>/PD+ controller reduced' */
%<tlcOutputsFcnOfS9B32>\
%endif
%if !WHITE_SPACE(tlcOutputsFcnOfS9B33)
/* {S!d1556}Scope: '<Root>/Scope6' */
%<tlcOutputsFcnOfS9B33>\
%endif
%if !WHITE_SPACE(tlcOutputsFcnOfS9B34)
/* {S!d1558}ToAsyncQueueBlock generated from: '<Root>/S-Function3' */
%<tlcOutputsFcnOfS9B34>\
%endif
%<SLibInsertSolverResetCode()>\
%closefile cfgTxt
%<cfgTxt>
%<LibSetSystemField(system, "CachedOutputLocalVars", localVarDecl)>
%endfunction
%function OutputsFcnProtoType(block, system) Output
%assign fcnProtoType = ""
%openfile fcnProtoType
static void Outputs(\
%assign comma = ""
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 16, fcnProtoType)>
%endfunction
